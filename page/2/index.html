<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.6.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="程序员的成长之路| 前端设计&amp;GIS开发 | 图书馆里的扫地僧 少林寺里的清洁工">
<meta property="og:type" content="website">
<meta property="og:title" content="Yao Blog">
<meta property="og:url" content="http://www.liyaolife.com/page/2/index.html">
<meta property="og:site_name" content="Yao Blog">
<meta property="og:description" content="程序员的成长之路| 前端设计&amp;GIS开发 | 图书馆里的扫地僧 少林寺里的清洁工">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Yao Blog">
<meta name="twitter:description" content="程序员的成长之路| 前端设计&amp;GIS开发 | 图书馆里的扫地僧 少林寺里的清洁工">

<link rel="canonical" href="http://www.liyaolife.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Yao Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Yao Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">图书馆里的清洁工 少林寺里的扫地僧</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/GeneralLi95" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.liyaolife.com/DMtrans2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Li Yao">
      <meta itemprop="description" content="程序员的成长之路| 前端设计&GIS开发 | 图书馆里的扫地僧 少林寺里的清洁工">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yao Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/DMtrans2/" class="post-title-link" itemprop="url">《Data Mining》第2章翻译 数据预处理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-06 21:00:30" itemprop="dateCreated datePublished" datetime="2018-05-06T21:00:30+08:00">2018-05-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-05-07 14:33:10" itemprop="dateModified" datetime="2018-05-07T14:33:10+08:00">2018-05-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="2-数据预处理"><a href="#2-数据预处理" class="headerlink" title="2 数据预处理"></a>2 数据预处理</h1><!--本章由程琳翻译-->
<blockquote>
<p>“凡事预则立，不预则废。”——孔子</p>
</blockquote>
<h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h2><p>真实数据的原始格式通常变化很大。许多值可能会丢失，不同数据源之间不一致，并且是错误的。对于分析人员来说，这会在有效使用数据方面带来诸多挑战。例如，考虑在社交媒体网站上评估消费者对其活动的兴趣的情况。分析人员可能首先需要确定对挖掘过程有价值的活动类型。该活动可以对应于用户输入的兴趣，用户输入的评论以及用户伴随兴趣而产生的朋友圈。所有这些信息都是多样的，需要从社交媒体网站的不同数据库中收集。此外，某些形式的数据（如原始日志）通常由于其非结构性而不能直接使用。换句话说，需要从这些数据源中提取有用的特征。因此，需要<strong>数据预处理阶段</strong>。</p>
<p>数据预处理阶段是一个多阶段过程，包含几个单独的步骤，其中一些或全部可用于给定的应用程序。这些步骤如下所示：</p>
<ol>
<li><p><strong>特征提取和可移植性</strong>：原始数据通常是不适合处理的形式。例子包括原始日志、文档、半结构化数据以及可能的其他形式的异构数据。在这种情况下，可能需要从数据中获得有意义的特征。一般而言，具有良好语义解释性的特征更为理想，因为它们简化了分析人员了解中间结果的能力。而且，它们通常更好地绑定到数据挖掘应用程序的目标。在某些情况下，数据是从多个来源获得的，需要将其集成到单个数据库中进行处理。另外，有些算法只能使用特定的数据类型，而数据可能包含不同类型的数据。在这种情况下，<strong>数据类型的可移植性</strong>在一种类型的属性转换为另一种类型时变得重要。这将生成可以通过现有算法处理的更均匀的数据集。</p>
</li>
<li><p><strong>数据清洗</strong>：在数据清洗阶段，从数据中删除丢失、错误和不一致的条目。另外，一些缺失的条目也可以通过称为<strong>插补</strong>的过程来估计。</p>
</li>
<li><p><strong>数据消减、选择和转换</strong>：在这个阶段，通过数据子集选择、特征子集选择或数据转换来减少数据的大小。这一阶段获得的收益是双重的。首先，当数据的大小减小时，算法通常更有效。其次，如果不相关的特征或不相关的记录被删除，数据挖掘过程的质量就会提高。第一个目标是通过通用采样和降维技术来实现的。要实现第二个目标，必须使用高度针对特定问题的方法来进行特征选择。例如，适用于群集的特征选择方法可能不适用于分类。</p>
</li>
</ol>
<p>某些形式的特征选择与手头的问题紧密结合。稍后关于聚类和分类等具体问题的章节将包含关于特征选择的详细讨论。</p>
<p>本章安排如下。特征提取阶段在章节2.2中讨论。数据清洗阶段在章节2.3中介绍。数据消减阶段在章节2.4解释。总结在章节2.5中给出。</p>
<h2 id="2-2-特征提取和可移植性"><a href="#2-2-特征提取和可移植性" class="headerlink" title="2.2 特征提取和可移植性"></a>2.2 特征提取和可移植性</h2><p>数据挖掘过程的第一阶段是创建一组分析人员可用的特征。在数据处于原始和非结构化形式（例如，原始文本、传感器信号）的情况下，需要提取相关特征进行处理。在其他情况下，以不同形式提供的混合特征往往不能用“现成”的分析方法进行处理。在这种情况下，可能需要将数据转换为统一的形式进行处理。这被称为<strong>数据类型移植</strong>。</p>
<h3 id="2-2-1-特征提取"><a href="#2-2-1-特征提取" class="headerlink" title="2.2.1 特征提取"></a>2.2.1 特征提取</h3><p>特征提取的第一阶段是非常关键的一步，尽管它非常适合特定的应用。在某些情况下，特征提取与数据类型可移植性的概念密切相关，其中一种类型的低级特征可能转换为另一种类型的高级特征。特征提取的性质取决于数据应用的领域：</p>
<ol>
<li><p><strong>传感器数据</strong>：传感器数据通常以大量的低电平信号收集。有时使用小波变换或傅里叶变换将低电平信号转换为更高级的特征。在其他情况下，时间序列在一些清洗后直接使用。信号处理领域有大量关于这种方法的文献。这些技术对于将时间序列数据移植到多维数据也很有用。</p>
</li>
<li><p><strong>图像数据</strong>：在其最原始的形式中，图像数据被表示为像素。在稍高的级别上，可以使用颜色直方图来表示图像不同部分的特征。最近，<strong>视觉词</strong>的使用变得越来越流行。这是一个语义丰富的表示，与文档数据类似。图像处理中的一个挑战是数据通常是非常大的尺寸。因此，取决于手头的应用，特征提取可以在不同的级别执行。</p>
</li>
<li><p><strong>Web日志</strong>：Web日志通常以预先指定的格式表示为文本字符串。由于这些日志中的字段被明确指定和分隔，因此将Web访问日志转换为（相关）分类和数字属性的多维表示相对比较容易。</p>
</li>
<li><p><strong>网络流量</strong>：在许多入侵检测应用程序中，网络数据包的特征用于分析入侵或其他有趣的活动。根据底层应用程序，可以从这些数据包中提取各种特征，例如传输的字节数、使用的网络协议等。</p>
</li>
<li><p><strong>文档数据</strong>：文档数据通常以原始和非结构化形式提供，并且数据可能包含不同实体之间丰富的语言关系。一种方法是删除停用词，停止数据，并使用袋装词表示法。其他方法使用<strong>实体提取</strong>来确定语言关系。</p>
<p>命名实体识别是信息提取的重要子任务。这种方法将文本中的原子元素定位和分类为人员、组织、位置、动作、数量等名称的预定义表达式。显然，识别这种原子元素的能力非常有用，因为它们可以用来理解句子和复杂事件的结构。这种方法也可以用于填充更传统的关系元素数据库或者更容易分析的原子实体序列。例如，请考虑以下语句：</p>
<p><em>比尔·克林顿住在查巴克。</em></p>
<p>在这里，“比尔·克林顿”是一个人的名字，“查巴克”是一个地方的名字。“住”一词表示一种行为。取决于当前的应用，每种类型的实体可能在数据挖掘过程具有不同的意义。 例如，如果数据挖掘应用程序主要关注提到特定位置，则需要提取“查巴克”一词。</p>
<p>用于命名实体识别的流行技术包括基于语言语法的技术和统计模型。语法规则的使用通常非常有效，但它需要经验丰富的计算语言学家的工作。另一方面，统计模型需要大量的训练数据。设计的技术通常是特定领域的。命名实体识别领域本身就很广泛，这超出了本书的范围。读者可以参考文献[400]详细讨论实体识别的不同方法。</p>
</li>
</ol>
<p>特征提取是一种艺术形式，高度依赖于分析人员选择最适合手头任务的特征及其表示。虽然数据分析的这个特定方面通常属于领域专家，但它也许是最重要的一个。如果不提取正确的特征，则分析只能基于可用数据。</p>
<h3 id="2-2-2-数据类型可移植性"><a href="#2-2-2-数据类型可移植性" class="headerlink" title="2.2.2 数据类型可移植性"></a>2.2.2 数据类型可移植性</h3><p>数据类型的可移植性是数据挖掘过程的关键要素，因为数据通常是异构的，并且可能包含多种类型。例如，人口统计数据集可能包含数字和混合属性。从心电图（ECG）传感器收集的时间序列数据集可能具有与其相关联的许多其他元信息和文本属性。这对于现在面临用任意数据类型组合设计算法的困难挑战的分析人员而言，是令人困惑的局面。数据类型的混合也限制了分析人员使用现成的工具进行处理的能力。请注意，在某些情况下移植数据类型确实会丢失代表性、准确性和表达性。理想情况下，最好根据特定的数据类型组合来定制算法以优化结果。然而，这是耗时且有时不切实际的。</p>
<p>本节将介绍在各种数据类型之间转换的方法。因为数字数据类型是数据挖掘算法中最简单和研究最广泛的数据类型，所以专注于如何将不同数据类型转换为数字数据类型尤其有用。但是，其他形式的转换在许多情况下也很有用。例如，对于基于相似性的算法，可以将几乎任何数据类型转换为图形，并将基于图形的算法应用于该表示。表2.1总结了在不同类型之间转换数据的各种方式。</p>
<h4 id="2-2-2-1-数字到分类数据：离散化"><a href="#2-2-2-1-数字到分类数据：离散化" class="headerlink" title="2.2.2.1 数字到分类数据：离散化"></a>2.2.2.1 数字到分类数据：离散化</h4><p>最常用的转换是从数字到分类数据类型。这个过程被称为离散化。离散化过程将数字属性的范围划分为φ个范围。然后，根据原始属性所在的范围，假定该属性包含从1到φ的φ个不同分类标注值。例如，考虑年龄属性。人们可以创建范围[0,10]，[11,20]，[21,30]等等。范围[11,20]中任何记录的符号值为“2”，范围[21,30]中记录的符号值为“3”。由于这些是符号值，因此在值“2”和“3”之间不会进行排序。此外，一个范围内的变化在离散化之后是不可区分的。因此，离散化过程的确会失去一些挖掘过程的信息。但是，对于某些应用程序而言，这种信息丢失不会太过虚弱。离散化的一个挑战是数据可能在不同的时间间隔内不均匀分布。例如，对于工资属性的情况，大量的人口子集可以被分组在[40,000,800,000]范围内，但很少会被分组在[1,040,000,1,080,000]范围内。请注意，这两个范围都具有相同的大小。因此，使用相同大小的范围可能对区分不同数据段不是很有帮助。另一方面，许多属性，如年龄，并不是非均匀分布的，因此相同大小的范围可能工作得相当好。离散化过程可以根据应用特定目标以各种方式执行：</p>
<ol>
<li><p>等宽范围：在这种情况下，每个范围[a，b]的选择方式使得b - a对于每个范围都是相同的。 这种方法的缺点是，它不适用于跨不同范围分布不均匀的数据集。 确定每个属性的最小值和最大值以确定范围的实际值。然后这个范围[min,max]将数据分成长度相等的φ个范围。</p>
</li>
<li><p>等值日志范围：每个范围[a，b]的选择方式使得log(b)-log(a)具有相同的值。对于某些α&gt; 1，这种范围选择具有几何范围[a，a·α]，[a·α，a·α2]等的作用。当属性在一个范围内显示指数分布时，这种范围可能很有用。事实上，如果一个属性的属性频率分布可以用函数形式建模，那么一个自然的方法是选择范围[a,b]，使得f(b)-f(a)对于某个函数f(·)相等。以这样的方式选择函数f(·)，使得每个范围包含大致相似数量的记录。然而，在大多数情况下，很难找到封闭形式的函数f(·)。</p>
</li>
<li><p>等深度范围：在这种情况下，选择范围以便每个范围具有相同数量的记录。这个想法是为每个范围提供相同的粒度级别。一个属性可以分为等深度范围，首先对它进行排序，然后在排序的属性值上选择分割点，以便每个范围包含相同数量的记录。</p>
</li>
</ol>
<p>离散化过程也可用于将时间序列数据转换为离散序列数据。</p>
<center>表2.1 不同数据类型的可移植性<br><img src="http://p6atp7tts.bkt.clouddn.com/15256127943205.jpg" alt=""><br></center>

<h4 id="2-2-2-2-分类到数字数据：二值化"><a href="#2-2-2-2-分类到数字数据：二值化" class="headerlink" title="2.2.2.2 分类到数字数据：二值化"></a>2.2.2.2 分类到数字数据：二值化</h4><p>在某些情况下，希望对分类数据使用数字数据挖掘算法。由于二进制数据是数字和分类数据的特殊形式，因此可以将分类属性转换为二进制形式，然后对二进制数据使用数字算法。如果分类属性具有φ个不同的值，则创建φ个不同的二元属性。每个二进制属性对应于分类属性的一个可能值。因此，φ个属性中恰好有一个值为1，其余的值为0。</p>
<h4 id="2-2-2-3-文本到数字数据"><a href="#2-2-2-3-文本到数字数据" class="headerlink" title="2.2.2.3 文本到数字数据"></a>2.2.2.3 文本到数字数据</h4><p>尽管文本的向量空间表示可以被认为是具有非常高维度的稀疏数字数据集，但是这种特殊的数字表示形式对于传统的数据挖掘算法并不是很适合。例如，通常使用专门的相似度函数，例如余弦，而不是文本数据的欧几里德距离。这就是文本挖掘本身就是一个独特领域的原因，它拥有自己的专业算法系列。不过，可以将文本集合转换为更适合使用数字数据挖掘算法的形式。第一步是使用潜在语义分析（LSA）将文本集合转换为具有较低维度的非稀疏表示。此外，在变换之后，每个文档 需要被缩放为 。这种缩放对于确保不同长度的文档以统一的方式处理是必需的。经过这种缩放之后，传统的数字度量（例如欧几里得距离）更有效地工作。LSA在章节2.4.3.3中讨论。请注意，LSA很少与这种缩放结合使用。相反，传统的文本挖掘算法直接应用于从LSA获得的简化表示。</p>
<h4 id="2-2-2-4-时间序列到离散序列数据"><a href="#2-2-2-4-时间序列到离散序列数据" class="headerlink" title="2.2.2.4 时间序列到离散序列数据"></a>2.2.2.4 时间序列到离散序列数据</h4><p>时间序列数据可以使用称为符号聚合近似（SAX）的方法转换为离散序列数据。该方法包括两个步骤：</p>
<ol>
<li><p>基于窗口的平均：将该序列划分为长度为w的窗口，并且计算每个窗口上的平均时间序列值。</p>
</li>
<li><p>基于值的离散化：（已经平均的）时间序列值被离散化为更小数量的近似等深度间隔。这与前面讨论的数值属性的等深度离散化相同。这个想法是确保每个符号在时间序列中具有近似相等的频率。间隔边界通过假定时间序列值是用高斯假设分布来构造的。 （窗口化的）时间序列值的均值和标准偏差以数据驱动的方式估计以实例化高斯分布的参数。高斯分布的分位数用于确定间隔的边界。这比对所有数据值进行排序以确定分位数更有效，对于长时间（或流式）时间序列来说，这可能是更实用的方法。为了获得最好的结果，这些值被离散化为一小部分（通常为3到10）的间隔。每个这样的等深度间隔被映射为符号值。这创建了时间序列的符号表示，其实质上是一个离散序列。</p>
</li>
</ol>
<p>因此，SAX可能被视为基于窗口平均的等深度离散化方法。</p>
<h4 id="2-2-2-5-时间序列到数字数据"><a href="#2-2-2-5-时间序列到数字数据" class="headerlink" title="2.2.2.5 时间序列到数字数据"></a>2.2.2.5 时间序列到数字数据</h4><p>这种特殊的转换非常有用，因为它可以使用时间序列数据的多维算法。用于这种转换的常用方法是离散小波变换（DWT）。小波变换将时间序列数据转换为多维数据，作为表示系列的不同部分之间的平均差异的一组系数。如果需要，可以使用最大系数的子集来减小数据大小。 这个方法将在章节2.4.4.1关于数据消减部分讨论。 另一种方法称为离散傅立叶变换（DFT），在第14章章节14.2.4.2讨论。这些变换的共同特点是各种系数不再像原始时间序列值那样依赖于相关性。</p>
<h4 id="2-2-2-6-离散序列到数字数据"><a href="#2-2-2-6-离散序列到数字数据" class="headerlink" title="2.2.2.6 离散序列到数字数据"></a>2.2.2.6 离散序列到数字数据</h4><p>这种转换可以分两步进行。第一步是将离散序列转换为一组（二进制）时间序列，其中该组中的时间序列的数量等于不同符号的数量。第二步是使用小波变换将每个时间序列映射到多维向量中。最后，将来自不同系列的功能组合起来创建一个单一的多维记录。</p>
<p>要将序列转换为二进制时间序列，可以创建一个二进制字符串，其中的值表示某个特定符号是否出现在某个位置。例如，考虑以下四个符号的核苷酸序列：</p>
<p>ACACACTGTGACTG</p>
<p>该系列可以转换为与符号A，C，T和G分别对应的以下四组二进制时间序列：</p>
<p>10101000001000<br>01010100000100<br>00000010100010<br>00000001010001</p>
<p>可以将小波变换应用于这些系列中的每一个以创建多维特征集。可以附加来自四个不同系列的特征来创建单个数字多维记录。</p>
<h4 id="2-2-2-7-空间到数字数据"><a href="#2-2-2-7-空间到数字数据" class="headerlink" title="2.2.2.7 空间到数字数据"></a>2.2.2.7 空间到数字数据</h4><p>空间数据可以通过使用与时间序列数据相同的方法转换为数字数据。主要区别是现在有两个上下文属性（而不是一个）。这需要修改小波变换方法。第2.4.4.1节将简要讨论如何在有两个上下文属性时推广一维小波方法。该方法相当一般，可用于任何数量的上下文属性。</p>
<h4 id="2-2-2-8-图像到数字数据"><a href="#2-2-2-8-图像到数字数据" class="headerlink" title="2.2.2.8 图像到数字数据"></a>2.2.2.8 图像到数字数据</h4><p>可以使用多维缩放（MDS）和频谱转换等方法将图像转换为数字数据。此方法适用于边缘加权的应用程序，并表示节点之间的相似性或距离关系。MDS的一般方法可以实现这一目标，并在第2.4.4.2节进行了讨论。谱方法也可用于将图像转换为多维表示。这也是一种将结构信息转换为多维表示的降维方案。这个方法将在第2.4.4.3节进行讨论。</p>
<h4 id="2-2-2-9-基于相似性应用的任何类型到图像"><a href="#2-2-2-9-基于相似性应用的任何类型到图像" class="headerlink" title="2.2.2.9 基于相似性应用的任何类型到图像"></a>2.2.2.9 基于相似性应用的任何类型到图像</h4><p>许多应用程序都基于相似性的概念。例如，聚类问题被定义为类似对象组的创建，而异常值检测问题被定义为识别其中与剩余对象明显不同的对象子集的问题。许多形式的分类模型，如最近邻分类器，也依赖于相似性的概念。配对相似性的概念可以通过使用邻域图来最好地得到。对于给定的一组数据对象$$O={O_1…O_n}$$，邻域图定义如下：</p>
<ol>
<li><p>为$O$中的每个对象定义单个节点。这由节点集$N$定义，包含$n$个节点，其中节点$i$对应于对象$O_i$。</p>
</li>
<li><p>如果距离$d（O_i，O_j）$小于特定阈值$α$，则在$O_i$和$O_j$之间存在边缘。或者，可以使用每个节点的$k$个最近邻。由于$k$-最近邻关系不是对称的，这导致有向图。边缘上的方向被忽略，并且平行边被去除。边$（i，j）$的权重$w_{ij}$等于对象$O_i$和$O_j$之间距离的核函数，因此较大的权重表示较大的相似性。热内核就是一个例子：</p>
<p>$$w_{ij}=e^{-d(O_i,O_j)^2/t^2}\tag{2.1}$$</p>
<p>这里，$t$是用户定义的参数。</p>
</li>
</ol>
<p>各种数据挖掘算法可用于网络数据。所有这些方法也可用于相似图。请注意，只要可以定义适当的距离函数，就可以为任何类型的数据对象清晰地定义相似度图。这就是距离函数设计对于任何数据类型都非常重要的原因。距离函数设计的问题将在第3章中讨论。请注意，此方法仅适用于基于相似性或距离概念的应用程序。不过，许多数据挖掘问题直接或间接地与相似性和距离的概念相关。</p>
<center>表2.1 不同数据类型的可移植性</center>

<h2 id="2-3-数据清洗"><a href="#2-3-数据清洗" class="headerlink" title="2.3 数据清洗"></a>2.3 数据清洗</h2><p>由于存在与数据收集过程相关的错误，数据清洗过程很重要。数据收集过程中可能会出现一些缺失条目和错误的来源。一些例子如下：</p>
<ol>
<li>由于与收集和传输有关的硬件限制，一些数据收集技术（如传感器）本质上不准确。由于硬件故障或电池耗尽，有时传感器可能会降低读数。</li>
<li>使用扫描技术收集的数据可能存在与其相关的错误，因为光学字符识别技术远非完美。此外，语音-文本数据也容易出错。</li>
<li>用户出于隐私原因可能不想公开他们的信息，或者他们可能故意公开不正确的信息。例如，经常观察到用户有时在诸如社交网络的自动化注册站点上错误地填写他们的生日。在某些情况下，用户可能会选择将几个字段留空。</li>
<li>大量的数据是手动创建的。数据输入过程中手动错误很常见。</li>
<li>负责数据收集的实体如果成本太高，可能不会为某些记录收集某些字段。因此，记录可能没有完全列举。</li>
</ol>
<p>上述问题可能是数据挖掘应用程序不准确的重要原因。需要使用方法从数据中删除或更正丢失和错误的条目。数据清洗有几个重要方面：</p>
<ol>
<li><strong>处理缺少的条目</strong>：由于数据收集的缺陷或数据的固有性质，数据中的许多条目可能保持未列举。这些缺失的条目可能需要估计。估计缺失条目的过程也被称为插补。</li>
<li><strong>处理不正确的条目</strong>：如果可以从多个来源获得相同的信息，则可能会检测到<strong>不一致</strong>。作为分析过程的一部分，这些不一致可以被删除。检测错误条目的另一种方法是使用关于数据已知信息的特定域的知识。例如，如果一个人的身高被列为6米，那很可能是不正确的。更一般地说，与剩余数据分布不一致的数据点通常是嘈杂的。这些数据点被称为异常值。但是，假设这些数据点总是由错误引起是危险的。例如，表示信用卡欺诈的记录可能与大多数（正常）数据中的模式不一致，但不应将其作为“不正确”数据删除。</li>
<li><strong>缩放和规范化</strong>：数据可能经常以不同的比例表示（例如年龄和薪水）。这可能会导致某些功能被无意中加权得太多，以致其他功能被隐式忽略。因此，规范不同的功能是非常重要的。</li>
</ol>
<p>以下部分将讨论数据清洗的各个方面。</p>
<h3 id="2-3-1-处理缺少的条目"><a href="#2-3-1-处理缺少的条目" class="headerlink" title="2.3.1 处理缺少的条目"></a>2.3.1 处理缺少的条目</h3><p>数据收集方法不完善的数据库中缺少条目。例如，用户调查往往无法收集所有问题的答案。在数据贡献是自愿的情况下，数据几乎总是不完整的。三类技术用于处理缺失的条目：</p>
<ol>
<li>任何包含缺失条目的数据记录都可能被完全删除。但是，当大多数记录包含缺失条目时，这种方法可能并不实际。</li>
<li>缺失的值可能会被估计或估算。但是，插补过程所产生的错误可能会影响数据挖掘算法的结果。</li>
<li>分析阶段的设计方式可以处理缺失值。许多数据挖掘方法固有地被设计为在缺失值的情况下稳健工作。这种方法通常是最合乎需要的，因为它避免了插补过程中固有的额外偏差。</li>
</ol>
<p>估计缺失条目的问题与分类问题直接相关。在分类问题中，专门处理单个属性，并使用其他功能估计其值。在这种情况下，缺失值可能出现在任何功能上，因此问题更具挑战性，尽管它从根本上说并没有不同。第10和11章中讨论的许多分类方法也可用于缺失值估计。另外，在章节18.5中讨论的矩阵完成方法也可以使用。</p>
<center><img src="http://p6atp7tts.bkt.clouddn.com/15256128468792.jpg" alt=""><br>图2.1 通过以数据为中心的方法来查找噪声</center>

<p>在依赖于数据的情况下，如时间序列或空间数据，缺失值估计要简单得多。在这种情况下，上下文记录的行为属性值用于插补过程。例如，在时间序列数据集中，可以使用在丢失属性之前或之后的时间戳的值的平均值来进行估计。或者，可以线性内插最后$n$个时间序列数据标记处的行为值以确定缺失值。对于空间数据的情况，估计过程非常相似，其中可以使用相邻空间位置处的值的平均值。</p>
<h3 id="2-3-2-处理不正确和不一致的条目"><a href="#2-3-2-处理不正确和不一致的条目" class="headerlink" title="2.3.2 处理不正确和不一致的条目"></a>2.3.2 处理不正确和不一致的条目</h3><p>用于删除或更正不正确和不一致条目的关键方法如下所示：</p>
<ol>
<li><strong>不一致性检测</strong>：通常在数据以不同格式的不同来源可用时完成。例如，一个人的姓名可能在一个来源中全部拼写出来，而另一个来源可能只包含姓名缩写和姓氏。在这种情况下，关键问题是重复检测和不一致性检测。这些主题是在数据库领域内的数据集成的总体框架下进行研究的。</li>
<li><strong>领域知识</strong>：根据指定不同属性间关系的属性或规则的范围，通常会提供大量的领域知识。例如，如果国家/地区是“美国”，那么城市领域不能是“上海”。许多数据清洗和数据审计工具已经被开发出来，它们使用这些领域知识和约束来检测不正确的条目。</li>
<li><strong>以数据为中心的方法</strong>：在这些情况下，数据的统计行为用于检测异常值。例如，图2.1中标记为“噪声”的两个隔离数据点是异常值。这些孤立点可能是由于数据收集过程中的错误而产生的。但是，这可能并非总是如此，因为异常可能是底层系统有趣行为的结果。因此，任何检测到的异常值在丢弃前可能需要手动检查。使用以数据为中心的方法进行清理有时会很危险，因为它们会导致从底层系统中删除有用的知识。异常值检测问题本身就是一种重要的分析技术，并在第8章和第9章中进行了详细讨论。</li>
</ol>
<p>解决错误和不一致条目的方法通常是高度特定于域的。</p>
<h3 id="2-3-3-缩放和标准化"><a href="#2-3-3-缩放和标准化" class="headerlink" title="2.3.3 缩放和标准化"></a>2.3.3 缩放和标准化</h3><p>在许多情况下，不同的特征代表不同的参考尺度，因此可能无法相互比较。例如，年龄等属性与薪水等属性的截然不同。后者的属性通常比前者大几个数量级。结果，对不同特征（例如，欧几里得距离）计算的任何集合函数将由较大幅度的属性支配。</p>
<p>为了解决这个问题，通常使用标准化。考虑第$j$个属性具有均值$μ_j$和标准偏差$σ_j$的情况。然后，第$i$个记录$\overline{X_i}$的第$j$个属性值$x^j_i$可以如下归一化：</p>
<p>$$z^j_i=\frac{x^j_i-μ_j}{σ_j}\tag{2.2}$$</p>
<p>在正态分布假设下，绝大多数标准化值通常位于$[-3,3]$范围内。</p>
<p>第二种方法使用<strong>最小最大比例缩放</strong>来将所有属性映射到范围$[0,1]$。令$min_j$和$max_j$表示属性$j$的最小值和最大值。那么，第$i$个记录$\overline{X_i}$的第$j$个属性值$x^j_i$可以如下缩放：</p>
<p>$$y^j_i=\frac{x^j_i-min_j}{max_j-min_j}\tag{2.3}$$</p>
<p>当最大值和最小值由于数据收集中的某些错误而导致极值异常值时，此方法无效。例如，考虑年龄属性，其中数据收集中的错误导致将附加的零附加到年龄，导致年龄值为800岁而不是80岁。在这种情况下，沿着年龄属性的大部分缩放数据将会在$[0,0.1]$的范围内，因此可以不强调该属性。标准化对于这种情况更加鲁棒。</p>
<h2 id="2-4-数据缩减和转换"><a href="#2-4-数据缩减和转换" class="headerlink" title="2.4 数据缩减和转换"></a>2.4 数据缩减和转换</h2><p>数据缩减的目标是更紧凑地表示它。当数据量较小时，应用复杂且计算量大的算法要容易得多。数据的减少可以根据行数（记录）或以列数（维度）来表示。数据减少确实会导致一些信息的丢失。使用更复杂的算法有时可以弥补数据减少导致的信息损失。在各种应用中使用不同类型的数据缩减：</p>
<ol>
<li><strong>数据采样</strong>：对来自底层数据的记录进行采样以创建更小的数据库。在样本需要动态维护的流场景中，采样通常要困难得多。</li>
<li><strong>特征选择</strong>：分析过程中只使用底层数据的一部分特征。通常，这些子集是以特定于应用程序的方式选择的。例如，适用于群集的特征选择方法可能不适用于分类，反之亦然。因此，本节将仅以有限的方式讨论特征子集的问题，并将更详细的讨论推迟到后面的章节。</li>
<li><strong>通过轴旋转减少数据</strong>：利用数据中的相关性以较小的维数表示它。这种数据缩减方法的例子包括文本域的主成分分析（PCA），奇异值分解（SVD）或潜在语义分析（LSA）。</li>
<li><strong>使用类型转换的数据缩减</strong>：这种数据缩减的形式与数据类型的可移植性密切相关。例如，通过离散小波变换将时间序列转换为尺寸更小，复杂度更低的多维数据。同样，通过使用嵌入技术，图可以转换为多维表示。</li>
</ol>
<p>上述各方面将在本节的不同部分进行讨论。</p>
<h3 id="2-4-1-采样"><a href="#2-4-1-采样" class="headerlink" title="2.4.1 采样"></a>2.4.1 采样</h3><p>抽样的主要优点是它简单，直观并且相对容易实施。使用的采样类型可能随手边的应用而变化。</p>
<h4 id="2-4-1-1-静态数据采样"><a href="#2-4-1-1-静态数据采样" class="headerlink" title="2.4.1.1 静态数据采样"></a>2.4.1.1 静态数据采样</h4><p>在整个数据已经可用时对数据进行采样要简单得多，因此基础数据点的数量预先知道。在无偏抽样方法中，选择并保留数据点的预定义分数$f$用于分析。这是非常简单的实现，并且可以通过两种不同的方式实现，取决于是否使用替换。</p>
<p>在从具有$n$个记录的数据组$D$中取样而没有替换的情况下，总共$\lceil n·f \rceil$个记录是从数据中随机挑选的。因此，样本中不包含重复项，除非原始数据集$D$也包含重复项。在用具有$n$个记录的数据集$D$进行替换的采样中，对记录进行顺序且独立于整个数据集$D$的采样，总共$\lceil n·f \rceil$倍。因此，重复是可能的，因为相同的记录可能被包括在顺序选择的样本中。通常，大多数应用程序不使用替换，因为不必要的重复对于某些数据挖掘应用程序（如异常值检测）可能造成麻烦。其他一些特殊的采样形式如下：</p>
<ol>
<li><p><strong>有偏抽样</strong>：在有偏的抽样中，由于对分析的重要性，故意强调数据的某些部分。一个典型的例子是时间衰减偏差，其中更新的记录有更大的机会被纳入样本，而陈旧的记录被纳入的可能性较低。在指数衰减偏差中，对$δ_t$时间单位前产生的数据记录$\overline{X}$进行采样的概率$p（\overline{X}）$与由衰变参数$λ$调节的指数衰减函数值成比例：$$p(\overline{X})∝e^{-\lambda\cdot\delta_t}\tag{2.4}$$</p>
<p>这里$e$是自然对数的基数。通过使用不同的$λ$值，可以适当调节时间衰减的影响。</p>
</li>
<li><p><strong>分层抽样</strong>：在一些数据集中，数据的重要部分可能由于其稀缺性而无法充分体现。因此，分层样本首先将数据划分为一组所需的层，然后根据应用特定的方式基于预定义的比例从这些层中的每一层独立采样。</p>
<p>例如，考虑一项衡量人口中不同个人生活方式的经济多样性的调查。因为其相对稀缺，即使是100万参与者的样本也不会采样到亿万富翁。然而，分层样本（按收入）将独立地从每个收入组中取样预定义的一部分参与者，以确保分析具有更好的鲁棒性。</p>
</li>
</ol>
<p>许多其他形式的有偏抽样是可能的。例如，在密度有偏抽样中，较高密度区域中的点的权重较小，以确保样本中稀有区域具有更高的代表性。</p>
<h4 id="2-4-1-2-数据流的水塘采样"><a href="#2-4-1-2-数据流的水塘采样" class="headerlink" title="2.4.1.2 数据流的水塘采样"></a>2.4.1.2 数据流的水塘采样</h4><p>一个特别有趣的采样形式是数据流的水塘采样。在水塘采样中，从数据流中动态维护$k$个点的样本。回想一下，流的体积非常大，因此无法将其存储在磁盘上进行采样。因此，对于流中的每个传入数据点，必须使用一组有效实现的操作来维护样本。</p>
<p>在静态情况下，样本中包含数据点的概率为$k/n$，其中$k$为样本量，$n$为“数据集”中的点数。在这种情况下，“数据集”不是静态的，不能存储在磁盘上。此外，$n$的值随着更多点的到达而不断增加，并且之前的数据点（样本外部）已经被丢弃。因此，采样方法在任何特定时刻都不完全了解流的以前历史。换句话说，对于流中的每个输入数据点，我们需要动态地做出两个简单的准入控制决策：</p>
<ol>
<li>应该用什么抽样规则来决定是否在样本中包含新来的数据点？</li>
<li>应该使用什么规则来决定如何从样本中剔除数据点以便为新插入的数据点“腾出空间”？</li>
</ol>
<p>幸运的是，设计数据流中的水塘采样算法相对简单[498]。对于$k$大小的储存器，流中的前$k$个数据点用于初始化储层。随后，对于第$n$个输入流数据点，应用以下两个准入控制决策：</p>
<ol>
<li>以概率$k/n$将第$n$个输入流数据点插入储层。</li>
<li>如果新插入的数据点被插入，则随机从旧的$k$个数据点中剔除一个为新到达的点腾出空间。</li>
</ol>
<p>可以证明，上述规则保留了来自数据流的无偏储存样本。</p>
<p><strong>引理2.4.1</strong>  <em>在$n$个流点到达后，任何流点包含在储层中的概率是相同的，并且等于$k/n$。</em></p>
<p><strong>证明</strong>：这个结果很容易通过归纳显示。在初始化前$k$个数据点时，定理是非常正确的。让我们（归纳地）假设在$（n-1）$个数据点被接收后它也是如此，因此每个点包含在储层中的概率为$k/（n-1）$。到达点包含在流中的概率是$k/n$，因此引理对于到达的数据点是成立的。它仍然需要证明数据流中剩余点的结果。对于一个输入数据点可能会出现两个不相交的情况事件，并且一个点被包含在储层中的最终概率是这两种情况的总和：</p>
<ol>
<li><p>传入的数据点未插入储存器。这个概率是$（n-k）/n$。 由于归纳假设中包含在水塘中的任何点的原始概率为$k/（n-1）$，因此一个点包含在储层中和情况1事件中的总体概率是二者的乘积$p_1=\frac{k(n-k)}{n(n-1)}$。</p>
</li>
<li><p>传入的数据点被插入到储存器中。情况2的概率等于传入数据点的插入概率$k/n$。随后，现有储层点以概率$（k-1）/k$保留，因为其中只有一个被剔除。因为归纳假设意味着数据流中的任何早期点最初都以概率$k/（n-1）$出现在储层中，这意味着给定了一个点包含在储层和情况2事件中的概率为上述三种概率的乘积$p_2$：</p>
<p>$$p_2=\left( \frac{k}{n} \right)\left( \frac{k-1}{k} \right)\left( \frac{k}{n-1} \right)=\frac{k(k-1)}{n(n-1)}\tag{2.5}$$</p>
</li>
</ol>
<p>因此，在第$n$个数据点到达之后，流点保留在储层中的总概率由$p_1$和$p_2$的和给出。可以证明这等于$k/n$。</p>
<p>有可能将水塘采样扩展到数据流中存在时间偏差的情况。需要指出的是，指数偏差的情况已在[35]中得到解决。</p>
<h3 id="2-4-2-特征子集选择"><a href="#2-4-2-特征子集选择" class="headerlink" title="2.4.2 特征子集选择"></a>2.4.2 特征子集选择</h3><p>数据预处理的第二种方法是特征子集选择。有些功能在已知不相关时可以丢弃。哪些功能是相关的？显然，这个决定取决于手头的应用。有两种主要类型的特征选择：</p>
<ol>
<li><p><strong>无监督特征选择</strong>：这对应于从数据中去除嘈杂和冗余的属性。无监督的特征选择最好根据其对集群应用程序的影响来定义，尽管适用范围更广。如果不使用聚类问题作为合适的上下文，则很难全面描述这些特征选择方法。因此，无监督特征选择方法的讨论推迟到第6章数据聚类部分。</p>
<center><img src="http://p6atp7tts.bkt.clouddn.com/15256128806389.jpg" alt=""><br>图2.2：在适当旋转的轴系统中的少量维度中表示的高度相关的数据</center>
</li>
<li><p><strong>监督特征选择</strong>：这种类型的特征选择与数据分类问题相关。在这种情况下，只有可以有效预测类属性的功能是最相关的。这些特征选择方法通常与用于分类的分析方法紧密结合。详细的讨论推迟到第10章数据分类部分。</p>
</li>
</ol>
<p>特征选择是数据挖掘过程的重要组成部分，因为它决定了输入数据的质量。</p>
<h3 id="2-4-3-轴旋转降维"><a href="#2-4-3-轴旋转降维" class="headerlink" title="2.4.3 轴旋转降维"></a>2.4.3 轴旋转降维</h3><p>在实际数据集中，不同属性之间存在相当多的相关性。在某些情况下，属性之间的硬性约束或规则可能会以其他方式唯一地定义某些属性。例如，个人的出生日期（定量表示）与他或她的年龄完全相关。在大多数情况下，相关性可能不尽相同，但是不同特征之间仍然存在显著的相关性。不幸的是，真实的数据集包含许多这样的冗余，在数据创建的初始阶段，这些冗余已经逃脱了分析人员的注意。这些相关性和约束对应于隐式冗余，因为它们意味着可以使用维度的某些子集的知识来预测其他维度的值。例如，考虑图2.2所示的三维数据集。在这种情况下，如果轴旋转到图中所示的方向，则新变换后的特征值中的相关性和冗余性将被移除。作为这种冗余移除的结果，整个数据可以（近似）沿着一维线表示。因此，此三维数据集的固有维数为1。其他两个轴对应于低变量维数。如果数据在图2.2所示的新轴系中表示为坐标，那么沿这些低方差维的坐标值变化不大。因此，在轴系旋转之后，这些尺寸可以被移除而没有太多的信息损失。</p>
<p>一个自然的问题就是如何以自动的方式确定如图2.2所示的相关消除轴系统。实现这一目标的两种自然方法是主成分分析（PCA）和奇异值分解（SVD）。这两种方法虽然在定义层面上不完全相同，但是密切相关。尽管主成分分析的概念在直观上更容易理解，但SVD是一个更为通用的框架，可用于执行PCA作为特例。</p>
<h4 id="2-4-3-1-主成分分析"><a href="#2-4-3-1-主成分分析" class="headerlink" title="2.4.3.1 主成分分析"></a>2.4.3.1 主成分分析</h4><p>通常在从每个数据点减去数据集的平均值之后应用PCA。但是，只要数据的平均值被单独存储，也可以不使用平均中心来使用它。该操作被称为平均居中，并且其导致以原点为中心的数据集。PCA的目标是将数据旋转到一个轴系统，在这个轴系统中，在少量维度中捕获最大变异量。从图2.2的例子可以直观地看出，这样一个轴系统受到属性之间的相关性的影响。我们将在下面展示一个重要的观察结果，即一个数据集沿特定方向的方差可以直接用其协方差矩阵表示。</p>
<p>设$C$是$n×d$数据矩阵$D$的$d×d$对称协方差矩阵。因此，$C$的$（i，j）$条目$c_{ij}$表示数据矩阵$D$的第$i$列和第$j$列（维度）之间的协方差。令$μ_i$表示沿第$i$维的平均值。具体而言，如果$x^m_k$是第$k$条记录的第$m$维，则协方差条目$c_{ij}$的值如下所示：</p>
<p>$$c_{ij}=\frac{\begin{matrix} \sum_{k=1}^n x^i_kx^j_k \end{matrix}}{n}-μ_iμ_j\ \ \forall{i,j\in{1…d}}\tag{2.6}$$</p>
<p>令$\overline{μ}=（μ_1…μ_d）$是代表沿着不同维度的均值的$d$维行向量。然后，前面提到的$d×d$计算公式2.6对于不同的$i$和$j$值可以用$d×d$矩阵形式紧凑地表示如下：</p>
<p>$$C=\frac{D_TD}{n}-\overline{μ}^T\overline{μ}\tag{2.7}$$</p>
<p>请注意，矩阵$C$的$d$条对角线条目对应于$d$个方差。协方差矩阵$C$是半正定的，因为可以证明，对于任何$d$维列向量$\overline{v}$，$\overline{v}_TC\overline{v}$的值等于$\overline{v}$上的数据集$D$的一维投影$D\overline{v}$的方差。</p>
<p>$$\overline{v}^TC\overline{v}=\frac{(D\overline{v})^TD\overline{v}}{n}-(\overline{μ}\overline{v})^2=Variance\ of\ 1-dimensional\ points\ in\ D\overline{v}\ge0\tag{2.8}$$</p>
<p>事实上，PCA的目标是相继确定正交矢量$\overline{v}$使$\overline{v}^TC\overline{v}$最大化。如何确定这样的方向？ 因为协方差矩阵是对称的且是半正定的，所以可以如下对角化：</p>
<p>$$C=P \Lambda P^T\tag{2.9}$$</p>
<p>矩阵$P$的列包含$C$的正交特征向量，$Λ$是包含非负特征值的对角矩阵。$\Lambda_{ii}$条目是与矩阵$P$的第$i$个特征向量（或列）相对应的特征值。这些特征向量表示沿着单位方向$\overline{v}$最大化方差$\overline{v}^TC\overline{v}$的前述优化模型的连续正交解。</p>
<p>这种对角化的一个有趣特性是特征向量和特征值都具有根据数据分布的几何解释。具体来说，如果数据表示的轴系被旋转到$P$列中的特征向量的正交集，则可以表明新变换的特征值的所有$\begin{pmatrix} d \ 2\end{pmatrix}$ 个协方差都是零。换句话说，最大的方差保存方向也是相关去除方向。此外，特征值表示沿着相应特征向量的数据的方差。实际上，对角矩阵$Λ$是轴旋转后的新的协方差矩阵。因此，具有大特征值的特征向量保持较大的方差，并且也被称为主要分量。由于用于推导该变换的优化公式的性质，仅包含具有最大特征值的特征向量的新轴系统被优化以保持固定数量的维度中的最大方差。例如，图2.2的散点图说明了各种特征向量，并且很明显，具有最大方差的特征向量是创建方差保持表示所需的全部。只保留少量具有大特征值的特征向量通常就足够了。</p>
<p>在不失一般性的情况下，可以假定$P$（和对应的对角矩阵$Λ$）的列从左到右排列，使得它们对应于递减的特征值。然后，变换后的数据矩阵$D’$在轴旋转到$P$的标准正交列后的新坐标系中，可以用下列线性变换代数计算：</p>
<p>$$D^\prime=DP \tag{2.10}$$</p>
<p>虽然变换后的数据矩阵$D’$的大小也是$n×d$，只有其第一个（最左边的）$k$列将显示值的显著变化。$D$的剩余$（d-k）$列中的每一列将近似等于旋转轴系统中数据的平均值。对于以均值为中心的数据，这$（d-k）$列的值几乎为0。因此，数据的维数可以减少，并且只有变换后的数据矩阵$D$的前$k$列。为表示目的可能需要保留。此外，可以证实，变换后的数据$D’=DP$的协方差矩阵是通过应用方程式的协方差定义的对角线矩阵$Λ$。公式2.7到$DP$（转换数据）和$\overline{μ}P$（转换平均值）分别代替$D$和$\overline{μ}$。得到的协方差矩阵可以用原始协方差矩阵$C$表示为$P^TCP$。用等式中的$C=P\Lambda P^T$代替。公式2.9显示了等价性，因为$P^TP=PP^T=I$。换句话说，因为$Λ$是对角的，所以相关性已经从转换后的数据中移除。</p>
<p>由沿着top-$k$特征向量的投影定义的数据集的方差等于$k$个对应特征值的总和。在许多应用中，特征值在前几个值后显示急剧下降。例如，图2.3说明了来自UCI机器学习库[213]的279维Arrythmia数据集的特征值的行为。图2.3a以增加的顺序显示特征值的绝对量值，而图2.3b显示在top-$k$特征值中保留的总变量量。图2.3b可以通过使用图2.3a中最小特征值的累加和来导出。值得注意的是，215个最小特征值包含的数据总方差不到1％，因此可以在基于相似性的应用程序的结果变化很小的情况下将其删除。请注意，Arrythmia数据集不是沿着许多维度对的非常强关联的数据集。然而，由于相关性在多个维度上的累积效应，因此降维是激烈的。</p>
<center><img src="http://p6atp7tts.bkt.clouddn.com/15256129691951.jpg" alt=""><br>图2.3 随着心律失常数据集（Arrythmia dataset）的特征值数量的增加，方差保持不变</center>

<p>矩阵$C$的特征向量可以通过使用[295]中讨论的任何数值方法或通过现成的特征向量求解器来确定。PCA可以扩展到使用称为内核技巧的方法来发现非线性嵌入。参考第10章的章节10.6.4.1，简要介绍了内核PCA。</p>
<h4 id="2-4-3-2-奇异值分解"><a href="#2-4-3-2-奇异值分解" class="headerlink" title="2.4.3.2 奇异值分解"></a>2.4.3.2 奇异值分解</h4><p>奇异值分解（SVD）与主成分分析（PCA）密切相关。然而，由于密切的关系，这些不同的方法有时会彼此混淆。在开始讨论SVD之前，我们说明它与PCA的关系。SVD比PCA更普遍，因为它提供了两套基本矢量而不是一套。SVD提供数据矩阵的行和列的基向量，而PCA仅提供数据矩阵的行的基向量。此外，在某些特殊情况下，SVD为数据矩阵的行提供了与PCA相同的基础：</p>
<p><em>对于其中每个属性的均值为0的数据集，SVD提供与PCA相同的基本向量和数据转换。</em></p>
<p>PCA的基本向量对平均转换不变，而SVD的基向量不是。当数据不是以中心为中心时，SVD和PCA的基向量将不会相同，并且可能得到定性不同的结果。SVD通常在没有均值集中的情况下应用于稀疏非负数据，例如文档项矩阵。定义SVD的正式方法是作为（或分解成）三个矩阵的可分解产物：</p>
<p>$$D=Q \Sigma P^T\tag{2.11}$$</p>
<p>这里，$Q$是具有正交列的$n×n$矩阵，其是左奇异向量。$Σ$是包含奇异值的$n×d$对角矩阵，其总是非负的，并且按照惯例，以非递增顺序排列。此外，$P$是具有正交列的$d×d$矩阵，它们是右奇异向量。请注意，对角矩阵$Σ$是矩形的而不是正方形的，但它被称为对角线，因为只有形式$Σ_{ii}$的输入不为零。线性代数的一个基本事实是这种分解总是存在的，并且可以在[480]中找到证明。$Σ$的非零对角元素的个数等于矩阵$D$的秩，为$min{n，d}$。此外，由于奇异向量的正交性，$P^TP$和$Q^TQ$都是单位矩阵。 我们提出以下意见：</p>
<ol>
<li><p>矩阵$Q$的列也是左奇异向量，是$DD^T$的正交特征向量。这是因为$DD^T =QΣ（P^TP）Σ^TQ^T=QΣΣ^TQ^T$。因此，作为$n×n$对角矩阵$ΣΣ^T$的对角项的非零奇异值的平方表示$DD^T$的非零特征值。</p>
</li>
<li><p>矩阵$P$的列也是右奇异向量，是$D^TD$的正交特征向量。在$d×d$对角矩阵$Σ^TΣ$的对角条目中表示的非零奇异值的平方是$D^TD$的非零特征值。请注意，$DD^T$和$D^TD$的非零特征值是相同的。矩阵$P$特别重要，因为它提供了与PCA中协方差矩阵的特征向量类似的基向量。</p>
</li>
<li><p>因为以均值为中心的数据的协方差矩阵是$\frac{D^TD}{n}$（参考等式2.7），并且SVD的右奇异向量是$D^TD$的特征向量，所以对于中心平均的数据来说，PCA的特征向量与SVD的右奇异向量相同。此外，奇异值分解中的平方奇异值是主成分分析特征值的$n$倍。这种等价性说明了为什么SVD和PCA可以为以均值为中心的数据提供相同的转换。</p>
</li>
<li><p>在不失一般性的情况下，可以假设$Σ$的对角条目按降序排列，并且矩阵$P$和$Q$的列也相应地排序。令$P_k$和$Q_k$分别是通过选择$P$和$Q$的前$k$列获得的截短的$d×k$和$n×k$矩阵。 设$Σ_k$是包含最高$k$个奇异值的$k×k$平方矩阵。然后，SVD分解产生原始数据集$D$的近似$d$维数据表示：</p>
<p>$$D\approx Q_kΣ_kP^T_k\tag{2.12}$$</p>
<p>$P_k$的列表示用于数据集简化表示的$k$维基系统。在这个$k$维基系统中的降维数据集由$n×k$数据集$D’_k=DP_k=Q_kΣ_k$，如等式2.10。$D$行中的每一行都是$D’_k$包含这个新轴系统中每个变换数据点的$k$坐标。通常，$k$的值比$n$和$d$都小得多。此外，不同于PCA，全$d$维变换数据矩阵$D’$的最右$（d-k）$列$D’=DP$将近似为0（而不是数据平均值），数据是否以平均值为中心。一般来说，PCA将数据投影到穿过数据平均值的低维超平面上，而SVD将数据投射到穿过原点的低维超平面上。PCA尽可能多地捕获数据的方差（或平均欧几里德距离），而SVD捕获尽可能多的关于起点的总欧氏距离的平方欧氏距离。这种近似数据矩阵的方法被称为截断SVD。</p>
</li>
</ol>
<p>在下文中，我们将显示截断SVD使关于原点的变换数据点的聚集平方欧几里得距离（或能量）最大化。令$\overline{v}$是$d$维列向量，$D\overline{v}$是数据集$D$在$\overline{v}$上的投影。考虑确定单位向量$\overline{v}$的问题，使得投影数据的欧几里德距离$（D\overline{v}）^T（D\overline{v}）$的平方和来自原点的点数最大化。将拉格朗日松弛$\overline{v}^TD^TD\overline{v}-λ（||\overline{v}||^2-1）$的梯度设置为0等价于特征向量条件$D^TD\overline{v}-λ\overline{v}=0$。由于右奇异向量是$D^TD$的特征向量，因此它的特征向量具有$k$个最大特征值（平方奇异值）的右奇异向量提供了使经转换和减少的数据矩阵$D’$中的保存能量最大化的基础。$D’_k=DP_k=Q_kΣ_k$。因为能量是距离原点的平方欧几里德距离之和，对轴旋转是不变的，所以能量在$D’_k$与$D’_kP^T_k=Q_kΣ_kP^T_k$中的相同。因此，$k-rank$奇异值分解是一个最大的能量保留因子分解。这个结果被称为Eckart-Young定理。</p>
<p>$（D\overline{v}）^T（D\overline{v}）$给出了数据集$D$沿奇异值向量$\overline{v}$的投影$D\overline{v}$的总保存能量，简化如下：</p>
<p>$$(D\overline{v})^T(D\overline{v})=\overline{v}^T(D^TD\overline{v})=\overline{v}^T(\sigma^2\overline{v})=\sigma^2$$</p>
<p>因为能量被定义为沿着标准正交方向的线性可分的总和，所以沿前$k$个奇异向量的数据投影中的保存能量等于前$k$个奇异值的平方和。请注意，数据集$D$中的总能量总是等于所有非零奇异值的平方和。可以证明，最大化保存的能量与最小化$k$-阶近似的平方误差（或失去的能量）是相同的。这是因为保留子空间中的能量和互补（丢弃）子空间中的损失能量之和总是恒定的，这等于原始数据集$D$中的能量。</p>
<p>纯粹从特征向量分析的角度来看，SVD提供了两种不同的视角来理解变换和减少的数据。变换后的数据矩阵既可以被视为$d×d$散布矩阵$D^TD$的前$k$个基本特征向量$P_k$上的数据矩阵$D$的投影$DP_k$，也可以直接被看作是缩放特征向量$Q_kΣ_k=DP_k$的$n×n$点积相似度矩阵$DD^T$。尽管提取$n×n$相似度矩阵的特征向量通常在计算上是昂贵的，但这种方法也推广到非线性降维方法，其中线性基向量的概念不存在于原始空间中。在这种情况下，为了提取非线性嵌入（参见表2.3），将点积相似度矩阵替换为更复杂的相似度矩阵。</p>
<p>SVD比PCA更普遍，并且可用于同时确定数据矩阵的$k$个基向量的子集及其具有最大能量的转置。后者可以用于理解$D^T$的互补转换特性。$Q_k$的正交列提供了用于（近似）变换与$D^T$的行对应的“数据点”的$k$维基础系统，并且矩阵$D^TQ_k=P_kΣ_k$包含相应的坐标。例如，在用户项目评分矩阵中，可能希望确定用户的简化表示或项目的简化表示。SVD为这两种简化提供了基础向量。截断SVD以$k$个主要潜在成分表示数据。第$i$个潜在分量用$D$和$D^T$的第$i$个基向量表示，它在数据中的相对重要性由第$i$个奇异值定义。通过将矩阵乘积$Q_kΣ_kP^T_k$分解成$Q_k$和$P_k$的列向量（即$D^T$和$D$的主导基向量），可以获得$k$个潜在分量的下列相加和：</p>
<p>$$Q_k\Sigma_kP^T_k=\sum_{i=1}^k \overline{q_i}\sigma_i\overline{p_i}^T=\sum_{i=1}^k \sigma_i(\overline{q_i}\overline{p_i}^T)\tag{2.13}$$</p>
<p>这里$\overline{q_i}$是$Q$的第$i$列，$\overline{p_i}$是$P$的第$i$列，而$σ_i$是$Σ$的第$i$个对角条目。每个潜在分量$σ_i（\overline{q_i}\overline{p_i}^T）$是具有秩1和能量$σ^2_i$的$n×d$矩阵。这种分解被称为频谱分解。简化基矢量与SVD矩阵分解的关系如图2.4所示。</p>
<center><img src="http://p6atp7tts.bkt.clouddn.com/15256130854039.jpg" alt=""><br>图2.4 矩阵分解在SVD中的互补性质</center>

<p>下面举例说明6×6矩阵的2秩截断奇异值分解：</p>
<p>$$D=\begin{pmatrix}2&amp; 2&amp;1&amp;2&amp;0&amp;0 \2 &amp; 3&amp;3&amp;3&amp;0&amp;0\1&amp;1&amp;1&amp;1&amp;0&amp;0\2&amp;2&amp;2&amp;3&amp;1&amp;1\0&amp;0&amp;0&amp;1&amp;1&amp;1\0&amp;0&amp;0&amp;2&amp;1&amp;2\end{pmatrix}\approx Q_2\Sigma_2P^T_2$$</p>
<p>$$\approx\begin{pmatrix}-0.41&amp; 0.17 \-0.65 &amp; 0.31\-0.23&amp;0.13\-0.56&amp;-0.20\-0.10&amp;-0.46\-0.19&amp;-0.78\end{pmatrix}\begin{pmatrix}8.4 &amp; 0 \0 &amp; 3.3\end{pmatrix}\begin{pmatrix}-0.41 &amp; -0.49&amp;-0.44&amp;-0.61&amp;-0.10&amp;-0.12 \0.21 &amp; 0.31&amp;0.26&amp;-0.37&amp;-0.44&amp;-0.68\end{pmatrix}$$</p>
<p>$$=\begin{pmatrix}1.55&amp;1.87&amp;\underline{1.67}&amp;1.91&amp;0.10&amp;0.04\2.46&amp;2.98&amp;2.66&amp;2.95&amp;0.10&amp;-0.03\0.89&amp;1.08&amp;0.96&amp;1.04&amp;0.01&amp;-0.04\1.81&amp;2.11&amp;1.91&amp;3.14&amp;0.77&amp;1.03\0.02&amp;-0.05&amp;-0.02&amp;1.06&amp;0.74&amp;1.11\0.10&amp;-0.02&amp;0.04&amp;1.89&amp;1.28&amp;1.92\end{pmatrix}$$</p>
<p>请注意，秩2矩阵是原始矩阵的一个很好的近似值。具有最大误差的条目在最终的近似矩阵中加下划线。有趣的是，这个条目也与原始数据中剩余矩阵的结构不一致（为什么？）。截断SVD通常会尝试纠正不一致的条目，并且此属性有时会用于降低容易出错的数据集中的噪声。</p>
<h4 id="2-4-3-3-潜在语义分析"><a href="#2-4-3-3-潜在语义分析" class="headerlink" title="2.4.3.3 潜在语义分析"></a>2.4.3.3 潜在语义分析</h4><p>潜在语义分析（LSA）是SVD方法在文本域中的一种应用。在这种情况下，数据矩阵$D$是包含$n$个文档中的归一化词频的$n×d$文档项矩阵，其中$d$是词典的大小。没有使用均值居中，但由于$D$的稀疏性，结果与PCA大致相同。$D$的稀疏性意味着$D$中的大多数项是0，并且每列的平均值远小于非零值。在这种情况下，可以证明协方差矩阵与$D^TD$近似成正比。数据集的稀疏性也导致了低固有维数。因此，在文本领域，LSA的维度降低是相当激烈的。例如，能够在少于300个维度上表示在100,000个维度的词典上绘制的语料库并不罕见。</p>
<p>LSA是一个典型的例子，说明某些维度的信息“丢失”实际上能够改善数据表示的质量。文本域存在两个与同义词和多义词相对应的主要问题。同义词是指两个词可能具有相同的含义。例如，“滑稽”和“欢闹”这两个词的意思大致相同。多义性是指这个事实，即同一个词可能意味着两个不同的东西。例如，“捷豹”一词可以指汽车或猫。通常，一个词的重要性只能在文档中的其他词的上下文中理解。这对于基于相似性的应用程序来说是一个问题，因为计算与使用词频的相似性可能不完全准确。例如，分别包含“滑稽”和“欢闹”两个词的两个文件在原始表示空间中可能不被认为足够相似。上述两个问题是同义词和多义词效应的直接结果。 LSA之后的截断表示法典型地消除了同义词和多义词的噪音影响，因为（高能量）奇异向量表示数据中的相关方向，并且沿着这些方向隐含地表示该词的适当上下文。由于使用中的个体差异而产生的变化隐含地编码在低能量方向上，无论如何都被截断。据观察，使用LSA可以实现文本应用的重大质量改进[184,416]。同义词效应方面的改进通常比多义词更大。这种SVD的噪声消除行为也在一般的多维数据集中得到证明[25]。</p>
<h4 id="2-4-3-4-PCA和SVD的应用"><a href="#2-4-3-4-PCA和SVD的应用" class="headerlink" title="2.4.3.4 PCA和SVD的应用"></a>2.4.3.4 PCA和SVD的应用</h4><p>虽然PCA和SVD主要用于数据压缩，但它们在数据挖掘中还有许多其他应用。一些例子如下：</p>
<ol>
<li>降噪：虽然去除PCA和SVD中较小的特征向量/奇异向量可能会导致信息丢失，但在许多情况下，它还可能导致数据表示质量的提高。主要原因是沿着小特征向量的变化通常是噪声的结果，并且它们的去除通常是有益的。一个例子是LSA在文本域中的应用，其中删除较小的组件导致文本的语义特征的增强。奇异值分解也用于去噪图像。这些特定于文本和图像的结果在任意数据域中也被证明是正确的[25]。因此，减少数据不仅仅是节省空间，而且实际上在许多情况下提供了定性优势。</li>
<li>数据估算：SVD和PCA可用于数据估算应用[23]，如协同过滤，因为即使从不完整的数据矩阵中可以估算出$k$值较小的简化矩阵$Q_k$，$Σ_k$和$P_k$。因此，整个矩阵可以近似重建为$Q_kΣ_kP^T_k$。这个应用程序在第18章第18.5节讨论。</li>
<li>线性方程：许多数据挖掘应用程序都是优化问题，其中解决方案被重新组合为线性方程组。对于任何线性系统$A\overline{y}=0$，任何具有0奇异值的$A$的奇异向量将满足方程组（见习题14）。因此，0个奇异向量的任何线性组合将提供解决方案。</li>
<li>矩阵求逆：SVD可用于$d×d$矩阵$D$的求逆。设$D$的分解由$QΣP^T$给出。那么，$D$的逆矩阵是$D^{-1}=PΣ^{-1}Q^T$。请注意，$Σ^{-1}$可以通过对$Σ$的对角项求倒数得到。该方法还可以推广到通过仅求$Σ$的非零对角条目的倒数来确定$k$秩矩阵$D$的Moore-Penrose广义逆$D^+$。通过执行转置$Σ$的附加操作，该方法甚至可以推广到非方阵。这种矩阵求逆运算在许多数据挖掘应用中是必需的，例如最小二乘回归（参见第11章第11.5节）和社会网络分析（参见第19章）。</li>
<li>矩阵代数：许多网络挖掘应用需要应用代数运算，例如计算矩阵的功率。这在随机游走方法中很常见（参见第19章），其中可能需要计算无向网络的对称邻接矩阵的第$k$个幂。这种对称邻接矩阵可以分解为$QΔQ^T$形式。这种分解的第$k$次方可以有效地计算为$D^k=QΔ^kQ^T$。事实上，矩阵的任何多项式函数都可以被有效地计算。</li>
</ol>
<p>SVD和PCA非常有用，因为矩阵和线性代数运算在数据挖掘中无处不在。SVD和PCA通过提供方便的分解和基本表示来促进这种矩阵运算。SVD被形象地称为“绝对是线性代数的一个高点”。[481]</p>
<h3 id="2-4-4-用类型转换降维"><a href="#2-4-4-用类型转换降维" class="headerlink" title="2.4.4 用类型转换降维"></a>2.4.4 用类型转换降维</h3><p>在这些方法中，降维与类型转换相结合。 在大多数情况下，数据会从更复杂的类型转换为不太复杂的类型，例如多维数据。 因此，这些方法实现了数据缩减和类型可移植性的双重目的。 本节将研究两种这样的转换方法：</p>
<ol>
<li><p>时间序列到多维：使用了许多方法，例如离散傅里叶变换和离散小波变换。 虽然这些方法也可以看作由上下文属性的各种时间戳定义的轴系统的旋转，但数据在旋转后不再依赖于相关性。 因此，可以以类似于多维数据的方式处理结果数据集。 由于其直观的简单性，我们将研究Haar小波变换。</p>
</li>
<li><p>加权图到多维：使用多维缩放和谱方法在多维空间中嵌入加权图，以便通过多维嵌入来捕获边上的相似度或距离值。</p>
</li>
</ol>
<p>本节将讨论这些技术中的每一种。</p>
<center>表2.2 小波系数计算的一个例子</center><br><img src="http://p6atp7tts.bkt.clouddn.com/15249143212707.jpg" alt=""><br><br>#### 2.4.4.1 哈尔(Haar)小波变换<br>小波是一种众所周知的技术，可用于多粒度分解并将时间序列数据汇总为多维表示。 哈尔小波是一种特别流行的小波分解形式，因为它的直观性和易于实现。 为了理解小波分解背后的直觉，将使用传感器温度的一个例子。<br><br>假设传感器测量从早晨到晚上12小时的温度。 假设传感器以1个样本/秒的速率采样温度。 因此，在一天的过程中，传感器将收集$12×60×60 = 43,200$个读数。 显然，这将不会在很多天和很多传感器上得到很好的扩展。 一个重要的观察结果是许多相邻的传感器读数非常相似，导致这种表示非常浪费。 那么，我们如何能够在少量空间中大致表示这些数据呢？ 我们如何确定读数发生“变化”的关键区域，并存储这些变化而不是重复值？<br><br>假设我们只存储整天的平均值。 这提供了一些关于温度的想法，但没有提供关于当天变化的其他信息。 现在，如果上半年和下半年的平均温度差也存储起来，那么我们可以从这两个值中得出当天的第一天和第二天的平均值。 这个原则可以递归地应用，因为这一天的前半部分可以分为第一季和第二季。 因此，利用四个存储值，我们可以在一天中的四个季度完美重建平均值。 该过程可以递归地应用到传感器读数的粒度级别。 这些“差异值”用于导出小波系数。 当然，我们还没有实现任何数据压缩，因为这些系数的数量可以显示为与原始时间序列的长度完全相等。<br><br>重要的是要明白，大的差异值告诉我们更多关于温度值的变化，而不是小的变化，因此它们对于储存更重要。 因此，粒度级别的归一化之后存储更大的系数值。 这种归一化，稍后讨论，存储代表更长时间尺度的系数是有偏见的，因为更长时间的趋势对于（全局）系列重建更具信息性。<br><br>更正式地，小波技术将时间序列分解成一组系数加权小波基向量。 每个系数代表特定时间范围两半之间时间序列的粗略变化。 小波基矢量是一个时间序列，以简单的阶跃函数的形式表示这种变化的时间范围。 小波系数具有不同的阶数，取决于分析的时间序列片段的长度，这也代表了分析的粒度。 高阶系数代表系列中的大趋势，因为它们对应较大的范围。 低阶系数捕获更多的局部趋势。 在提供更多符号描述之前，下面分两步提供时间序列段S的小波分解的简单递归描述：<br><br>1. 将S的第一和第二时间半部分之间的行为属性值的平均差异的一半报告为小波系数。<br><br>2. 递归地将这种方法应用于S的第一和第二时间半部分。<br><center><img src="http://p6atp7tts.bkt.clouddn.com/15249155436388.jpg" alt=""></center><br><center>图2.5 小波分解的例证</center>

<p>在该过程结束时，执行还原过程，其中保留较大（归一化）的系数。 该标准化步骤将在后面详细描述。</p>
<p>在这一点上将提供更正式的和符号密集的描述。 为了便于讨论，假设系列的长度$q$是2的幂。对于$k≥1$的每个值，Haar小波分解定义$k$阶的$2^{k-1}$个系数。这$2^{k-1}$系数中的每一个都对应于长度为$q/ 2^{k-1}$的时间序列的连续部分。这$2^{k-1}$系数的第$i$个对应于从位置$（i-1）·q / 2^{k-1}+1$开始到位置$i·q /2^{k-1}$的序列中的分段。让我们用$\psi^i_k$表示这个系数，用$S^i_k$表示相应的时间序列片段。同时，让我们将$S^i_k$的前半部分的平均值定义为$a^i_k$，将后半部分的平均值定义为$b^k_i$。那么，$\psi^i_k$的值由$(a^i_k-b^i_k)/2$给出。 更正式地说，如果$\phi^i_k$表示$S^i_k$的平均值，那么可以递归地定义$\psi^i_k$的值如下：<br>$$\psi^i_k=(\phi^{2 \cdot i-1}<em>{k+1}-\phi^{2 \cdot i}</em>{k+1})/2 \tag{2.14}$$</p>
<p>Haar系数集由1到$\log_2(q)$的所有系数定义。 此外，为了完美重建，需要全局平均值$\phi^1_1$。系数的总数恰好等于原始序列的长度，并且通过丢弃较小（归一化）的系数来获得降维。这部分我们会在后面继续讨论。</p>
<center><img src="http://p6atp7tts.bkt.clouddn.com/15249177317640.jpg" alt=""></center><br><center>图2.6： 小波分解的错误树</center>

<p>不同订单的系数以特定的粒度级别了解数据的主要趋势。例如，系数$\phi^i_k$是片段$S^i_k$的前半部分大于同一片段后半部分的量的一半。由于较大的$k$值对应于几何缩小的段大小，因此可以在不同粒度级别上理解基本趋势。 Haar小波的这种定义使得通过一系列平均和差分操作非常容易进行计算。表2.2显示了序列$（8,6,2,3,4,6,6,5）$的小波系数的计算。这种分解在图2.5中以图形形式说明。请注意，原始序列中的每个值都可以表示为$\log_2(8)= 3$小波系数的总和，前面加上正号或负号。通常，整个分解可以表示为深度3的树，其表示整个系列的分层分解。这也被称为错误树。在图2.6中，说明了表2.2中小波分解的误差树。树中的节点包含小波系数的值，但包含系列平均值的特殊超根节点除外。</p>
<p>该系列中小波系数的数量是8，这也是原始系列的长度。 原始序列已复制到图2.6中错误树的正下方，并可通过在沿着通向该值的路径上的节点中添加或减去值来重建。 如果我们使用它下面的左分支来达到系列值，则应该添加节点中的每个系数。 否则，应该减去它。 这种自然分解意味着可以通过仅使用与其相关的错误树的部分来重建沿着该系列的整个连续范围。</p>
<p>与所有降维方法一样，较小的系数被忽略。 我们将借助与每个系数相关的基向量的概念来解释丢弃系数的过程：</p>
<p><em>小波表示是将长度为q的原始时间序列分解为彼此正交的q个“更简单”时间序列（或小波）的集合的加权和。 这些“更简单”的时间序列是基本向量，小波系数表示分解中不同基向量的权重。</em></p>
<p>图2.5显示了这些“更简单”的时间序列及其相应的系数。小波系数（和基向量）的数量等于系列q的长度。<br>代表每个基矢量的时间序列的长度也是q。每个基矢量在连续的时间序列段中具有+1或-1的值，通过差分操作从中得出特定的系数。否则，该值为0，因为小波与时间序列中该区域的变化无关。基矢的非零段的前半部分是+1，后半部分是-1。当它被绘制成时间序列时，这给出了小波的形状，并且还反映了相关时间序列片段中的差异操作。乘以系数的基向量具有建立加权时间序列的作用，其中第一半和第二半之间的差异反映了原始时间序列中相应段之间的平均差异。因此，通过在错误树中将不同粒度级别的所有这些加权小波相加，就可以重建原始序列。图2.5中的基向量列表是以下矩阵的行：</p>
<p>$$\begin{pmatrix} 1 &amp;-1 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp; 0 \ 0 &amp;0 &amp;1 &amp;-1 &amp;0 &amp;0 &amp;0 &amp; 0\ 0 &amp;0 &amp;0 &amp;0 &amp;1 &amp;-1 &amp;0 &amp; 0\ 0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;0 &amp;1 &amp;-1\ 1 &amp;1 &amp;-1 &amp;-1 &amp;0 &amp;0 &amp;0 &amp; 0\ 0 &amp;0 &amp;0 &amp;0 &amp;1 &amp;1 &amp;-1 &amp;-1\ 1 &amp;1 &amp;1 &amp;1 &amp;-1 &amp;-1 &amp;-1 &amp;-1\ 1 &amp;1 &amp;1 &amp;1 &amp;1 &amp;1 &amp;1 &amp;1<br>\end{pmatrix}$$</p>
<p>请注意，任何一对基矢量的点积是0，因此这些系列彼此正交。 最详细的系数只有一个+1和一个-1，而最粗略的系数有四个+1和-1个条目。 此外，需要使用向量$（11111111）$来表示系列平均值。</p>
<p>对于时间序列$T$，令$\overline{W_1}…\overline{W_q}$是相应的基本向量。那么，如果$a_1…a_q$是基向量$\overline{W_1}…\overline{W_q}$的小波系数，时间序列$T$可以表示如下：<br>$$T = \sum_{i=1}^qa_i\overline{W_i}=\sum_{i=1}^q(a_i||\overline{W_i}||)\frac{\overline{W_i}}{||\overline{W_i}||} \tag{2.15}$$</p>
<p>图2.5中表示的系数是未标准化的，因为基向量没有单位标准化。虽然$a_i$是图2.5中的非标准化值，但值$a_i || W_i ||$ 代表归一化的系数。$|| W_i ||$的值对于不同次序的系数是不同的，在这个特例中等于$\sqrt{2}$，$\sqrt{4}$或$\sqrt8$。例如，在图2.5中，最大层次的非归一化系数是-0.25，而相应的归一化值是$-0.25\sqrt8$。归一化之后，基向量$\overline{W_1}…\overline{W_q}$是正交的，因此，相应（归一化）系数的平方和等于近似时间序列中的保留能量。 由于归一化后的系数在轴旋转之后提供了一个新的坐标表示，所以如果系数没有丢失，则时间序列之间的欧几里德距离将保留在这个新的表示中。 可以证明，通过保留具有最大归一化值的系数，小波表示中的误差损失被最小化。</p>
<p>前面的讨论集中在单个时间序列的逼近上。 实际上，人们可能想要将N个时间序列的数据库转换为N个多维向量。 当多个时间序列数据库可用时，可以使用两种策略：</p>
<ol>
<li><p>为每个系列选择相同基础矢量的系数，以创建一个有意义的低维度多维数据库。 因此，选择N个不同序列中具有最大平均归一化系数的基向量。</p>
</li>
<li><p>小波系数表示的全部维度被保留。 然而，对于每个时间序列，最大归一化系数（幅度）是单独选择的。 剩下的值被设置为0.这导致了一个稀疏的高维度数据库，其中许多值为0.像SVD这样的方法可以作为进一步降低维度的第二步应用。 这种方法的第二步缺点是失去了小波变换特征的可解释性。 回想一下，哈尔小波是少数几个降维变换之一，其中系数在特定时间序列段的特定趋势方面确实具有一定的可解释性。</p>
</li>
</ol>
<p>小波分解方法通过仅保留少量系数为降维（和数据类型转换）提供了一种自然的方法。</p>
<center><img src="http://p6atp7tts.bkt.clouddn.com/15249202886163.jpg" alt=""></center><br><center>图2.7 说明包含海面温度的网格中空间数据的小波分解的顶层</center>

<p><strong>具有多个上下文属性的小波分解</strong><br>时间序列数据包含与时间值相对应的单个上下文属性。 这有助于简化小波分解。 但是，在某些情况下，如空间数据，可能会有两个与X坐标和Y坐标对应的上下文属性。 例如，在使用两个坐标描述的空间位置处测量海面温度。 在这种情况下如何进行小波分解？ 在本节中，提供了将小波扩展到多个上下文属性的简要概述。</p>
<p>假设空间数据以尺寸为$q \times q$的二维网格的形式表示。 回想一维情况下，通过连续划分时间序列以分层方式对时间序列的连续段应用差分操作。 相应的基向量在相关位置处具有+1和-1。 二维情况完全类似于连续分区使用空间网格的连续区域。 这些分区沿着不同的轴交替进行。 相应的基本矢量是尺寸为$q \times q$的二维矩阵，用于调节差分操作的执行方式。</p>
<p>图2.7说明了二维分解策略的一个例子。图中只显示了分解的前两个层次。这里以空间温度的$4 \times 4$网格为例。沿着X轴的第一个分区将空间区域分成两个大小为$4 \times 2$的块。相应的二维二元基矩阵被示为相同的图。下一阶段在分层分解过程中将这些$4 \times 2$块中的每一块划分为大小为$2 \times 2$的块。与一维时间序列的情况一样，小波系数是被分解的相关块的两半之间的平均温度的一半差异。沿着X轴和Y轴的交替分割过程可以进行到各个数据条目。这创建了分层小波误差树，其具有与1维情况中创建的许多类似的属性。这种分解的总体原理与1维情况几乎相同，不同层次的切割如何通过在不同层次交替进行而产生主要差异。该方法可以扩展到$k&gt; 2$的上下文属性的情况下，使用在树的不同级别上选择的轴上的循环旋转进行差异化操作。</p>
<h4 id="2-4-4-2-多维度缩放"><a href="#2-4-4-2-多维度缩放" class="headerlink" title="2.4.4.2 多维度缩放"></a>2.4.4.2 多维度缩放</h4><p>图是用于表示对象之间关系的强大机制。 在某些数据挖掘场景中，对象的数据类型可能非常复杂且异构，如用文本和其他数字属性注释的时间序列。 然而，基于应用程序特定的目标，几对数据对象之间的距离之间的明确概念可能是可用的。 如何可视化这些对象之间的内在相似性？ 一个人如何想象社交网络中两个人的“接近度”？ 这样做的一种自然方式是多维缩放（MDS）的概念。 虽然MDS最初是在图形结构距离的空间可视化的背景下提出的，但它在嵌入多维空间中任意类型的数据对象方面具有更广泛的适用性。 这种方法还可以在嵌入数据上使用多维数据挖掘算法。</p>
<p>对于体格n个节点的图，令$\delta_{ij}=\delta_{ji}$表示节点$i$和$j$之间的具体距离。它假设了所有$\binom{n}{2}$对节点之间的距离都是明确的。希望将n个节点映射到n个不同的k维向量$\overline{X_i}…\overline{X_j}$，使得多维空间中的距离与距离图中的$\binom{n}{2}$距离值紧密对应。 在MDS中，这$n$个点中每一个点的$k$坐标都被视为需要优化的变量，以便它们能够拟合当前的成对距离集。公制MDS也称为经典MDS，试图解决以下优化（最小化）问题：<br>$$O=\sum_{i,j:i&lt;j}(||\overline{X_i}-\overline{X_j}||-\delta_{ij})^2 \tag{2.16}$$</p>
<p>此处，$||\cdot||$代表欧几里得常数。换句话说，每个节点都由一个多维数据点表示，这样这些点之间的欧几里得距离尽可能接近地反映了图的距离。 在其他形式的非度量MDS中，这个目标函数可能是不同的。 这个优化问题因此具有$n\cdot k$个变量，并且它随着数据$n$的大小和嵌入的期望维度$k$而缩放。公式2.16中的对象$O$通常被$\sum_{i,j:i&lt;j}\delta^2_{ij}$来产生一个位于$(0,1)$范围内的值。这个值的平方根被称为<em>克鲁斯卡尔压力(Kruskal stress)</em>。</p>
<p>经典MDS的基础假设是距离矩阵$\Delta=[\delta^2_{ij}]_{n\times n}$ 是通过计算一些假设的数据矩阵$D$中的成对欧氏距离产生的，其条目和维度是未知的。在经典的MDS中，矩阵$D$永远无法完全恢复，因为欧几里德距离对于平移和轴旋转是不变的。 数据平均值和轴方向的适当约定将在后面讨论。 尽管公式2.16的优化需要数值技术，但是在特定距离矩阵为欧几里得的假设下，可以通过特征分解获得经典MDS的直接解决方案：</p>
<ol>
<li><p>借助欧几里得空间中的余弦定律，任意两两（平方）距离矩阵$\Delta=[\delta^2_{ij}]<em>{n\times n}$可以转换为对称点积矩阵$S</em>{n\times n}$。特别是，如果$\overline{X_i}$和$\overline{X_j}$是第$i$个和第$j$个节点的嵌入表示，则$\overline{X_i}$和$\overline{X_j}$之间的点积可以与距离相关如下：<br> $$\overline{X_i}\cdot \overline{X_j}= -\frac{1}{2}[||\overline{X_i}-\overline{X_j}||^2-||\overline{X_i}+\overline{X_j}||^2] ~~~\forall i,j \in {1..n} \tag{2.17}$$<br> 对于以平均值为中心的嵌入，$||\overline{X_i}||^2+||\overline{X_j}||^2$的值可以用可以用距离矩阵$\Delta$的条目表示（见练习9），如下所示：<br>$$||\overline{X_i}||^2+||\overline{X_j}||^2=\frac{\sum_{p=1}^n ||\overline{X_i}-\overline{X_p}||^2 }{n}+\frac{\sum_{q=1}^n ||\overline{X_j}-\overline{X_q}||^2 }{n}-\frac{\sum_{p=1}^n \sum_{1=1}^n||\overline{X_p}-\overline{X_q}||^2 }{n^2} \tag{2.18}$$<br>平均中心假设是必要的，因为欧几里得距离是平均不变量，而点积不是。 通过把方程2.18带入方程2.17，可以完全根据距离矩阵$\Delta$的条目表达点积$\overline{X_i}\cdot \overline{X_j}$。由于这个条件对于$i$和$j$的所有可能值都是正确的，所以我们可以方便地用$n×n$矩阵形式表达它。令$U$是所有1的$n×n$矩阵，并令$I$为单位矩阵。然后，我们上面的论证显示点积矩阵$S$等于$-\frac{1}{2}(I-\frac{U}{n})\Delta(I-\frac{U}{n})$。在欧几里德假设下，矩阵$S$总是正半正定，因为它等于未知维数的未观测数据矩阵$D$的$n×n$点积矩阵$DD^T$。因此，希望将$S$的高质量因子分解确定为形式$D_kD_k^T$，其中$D_k$是维数$k$的$n×k$矩阵。</p>
</li>
<li><p>这种分解可以通过特征分解来获得。令$S\approx Q_k\sum^2_kQ^T_k=(Q_k\sum_k)(Q_k\sum_k)^T$表示$S$的近似对角化，其中$Q_k$是包含$S$的最大$k$个特征向量的$n \times k $矩阵，并且$\sum^2_k$是一个$k \times k$的包含特征值的对角矩阵。嵌入表示由$D_k =Q_k\sum_k$给出。请注意，SVD也可以将最佳嵌入作为原始数据点积矩阵的缩放特征向量。 因此，这种方法使表示的平方误差最小化。 这也可以被证明相当于最小化Kruskal压力。</p>
</li>
</ol>
<p>最佳解决方案并不是唯一的，因为我们可以将$Q_k\sum_k$与任何具有正交列的$k \times k$矩阵相乘，并且成对的欧几里德距离不会受到影响。换句话说，旋转轴系统中$Q_k \sum_k$的任何表示也是最优的。MDS找到像PCA这样的轴系统，其中各个属性是不相关的。事实上，如果将经典MDS应用于通过计算实际数据集中的成对欧几里得距离构造的距离矩阵$\Delta$，则它将产生与在该数据集上应用PCA相同的嵌入。当这种数据集不可用时，MDS非常有用，并且只有距离矩阵$\Delta$可用。</p>
<p>与所有降维方法一样，维度k的值提供了表示大小和准确性之间的交换。维数$k$的较大值将导致较低的应力。大量的数据点通常需要更大的表示维度来实现相同的压力。然而，最关键的因素是距离矩阵的内在结构。例如，如果一个$10,000\times10,000$的距离矩阵包含$10,000$个城市之间的成对驾驶距离，通常可以用二维表示来很好地近似。这是因为驾驶距离是二维空间中欧几里德距离的近似值。另一方面，任意距离矩阵可能不是欧几里德距离，这些距离甚至可能不满足三角不等式。结果，矩阵$S$可能不是正半正定。在这种情况下，有时仍然可以使用度量假设来获得高质量的嵌入。具体而言，只能使用那些正特征值，其幅度超过最负特征值的特征值。如果负特征值的幅度很小，这种方法效果很好。</p>
<p>MDS常用于非线性降维方法，如ISOMAP（参见第3章第3.2.1.7节）。值得注意的是，在常规SVD中，$n\times n$点积相似度矩阵$DD^T$的缩放特征向量产生$D$的低维嵌入表示，就像$S$的特征向量产生MDS中的嵌入一样。 相似矩阵的特征分解是许多线性和非线性降维方法的基础，如PCA，SVD，ISOMAP，核PCA和谱嵌入。 每个嵌入的特定属性是选择相似性矩阵和所得特征向量上使用的缩放比例的结果。表2.3提供了这些方法的初步比较，尽管其中一些仅在后面的章节中详细讨论。</p>
<center>表2.3 各种相似性矩阵的缩放特征向量产生具有不同属性的嵌入</center><br><center><img src="http://p6atp7tts.bkt.clouddn.com/15249278299467.jpg" alt=""></center>


<h4 id="2-4-4-3-图谱的谱变换和嵌入"><a href="#2-4-4-3-图谱的谱变换和嵌入" class="headerlink" title="2.4.4.3 图谱的谱变换和嵌入"></a>2.4.4.3 图谱的谱变换和嵌入</h4><p>鉴于MDS方法是为保存全球距离而设计的，谱方法的设计是为了保存聚类等应用的局部距离。 光谱方法与相似度图一起工作，其中边缘的权重代表相似性而不是距离。 当距离值可用时，它们被转换为具有内核函数的相似值，例如本章前面讨论的热内核。由于同源性的概念，相似性的概念对于许多真实的网络，社交和信息网络来说很自然。例如，考虑一个书目网络，其中节点对应于作者，边缘对应于共同作者关系。边的权重表示作者之间的出版物数量，因此表示作者出版物中可能的相似概念。相似图也可以在任意数据类型之间构建。例如，一组n个时间序列可以转换成一个有n个节点的图，其中一个节点表示每个时间序列。边的权重等于两个节点之间的相似度，并且只保留具有“足够”相似水平的边。第2.2.2.9节提供了关于相似图构造的讨论。因此，如果可以将相似图转换为保留节点之间相似性结构的多维表示，则它提供了一种转换，可以将任何数据类型虚拟地转换为易于使用的多维表示。这里需要注意的是，这种转换只能用于基于相似性的应用，如聚类或最近邻分类，因为转换的目的是保持局部相似性结构。数据集的局部相似性结构对于许多数据挖掘应用程序而言至关重要。</p>
<p>令$G =（N，A）$为节点集$N$和边集$A$的无向图。假设节点集包含$n$个节点。 对称$n\times n$权重矩阵$W = [w_{ij}]$表示不同节点之间的相似度。与MDS一起使用完整的全局距离图，MDS通常是稀疏表示每个对象与其最近k个对象的相似性（参见2.2.2.9节）。与其他对象的相似性不会相互区分并设置为0.这是因为频谱方法仅保留聚类等应用程序的局部相似性结构。 这个矩阵中的所有条目都被假定为非负的，并且较高的值表示较大的相似性。 如果在一对节点之间不存在边缘，则相应的条目被假定为0.希望将该图的节点嵌入到$k$维空间中，以便保持数据的相似性结构。</p>
<p>首先，让我们讨论将节点映射到一维空间的更简单的问题。对$k$维情况的推广是相对直接的。 我们想将$N$中的节点映射成一组一维实数值$y_1…y_n$在一条线上，这样这些点之间的距离反映了节点之间的边缘连通性。 因此，将连接高权重边的节点映射到该线上的远端点是不理想的。 因此，我们想确定$y_i$的最小化以下目标函数$O$的值：<br>$$O=\sum_{i=1}^n\sum_{j=1}^nw_{ij}(y_i-y_j)^2 \tag{2.19}$$</p>
<p>这个目标函数惩罚$y_i$和$y_j$之间的距离，权重与$w_{ij}$成正比。因此，当$w_{ij}$非常大（更相似的节点）时，数据点$y_i$和$y_j$将更可能在嵌入式空间中更接近彼此。目标函数$O$可以用权重矩阵$W$的拉普拉斯矩阵$L$重写。拉普拉斯矩阵$L$定义是$\Lambda-W$，其中$\Lambda$是一个对角矩阵$\Lambda_{ii}=\sum_{j=1}^nw_{ij}$。设嵌入值的$n$维列向量表示为$\overline{y}=(y_1 … y_n)^T$。 在一些代数简化后，可以用拉普拉斯矩阵来重写最小化目标函数$O$：<br>$$O=2\overline{y}^TL\overline{y} \tag{2.20}$$</p>
<p>矩阵$L$是具有非负特征值的正半正定矩阵，因为和平方目标函数$O$总是非负的。我们需要合并缩放约束来确保所有$i$的$y_i = 0$的平凡值不被优化方案选择。可能的缩放限制如下：<br>$$\overline{y}^T\Lambda\overline{y}=1 \tag{2.21}$</p>
<p>在方程2.21的约束中使用矩阵$\Lambda $基本上是一个归一化约束，这在19章的19.3.4节中有详细讨论。</p>
<p>可以证明，通过选择$y$作为关系$\Lambda^{-1}L\overline{y} =\lambda \overline{y}$的最小特征向量来优化$O$的值。然而，最小的特征值总是0，并且它对应于节点嵌入$y$与仅包含1的矢量成比例的平凡解。这个平凡的特征向量是非信息性的，因为它对应于每个节点都映射到相同点的嵌入。 因此，它可以被丢弃，并且不用于分析。然后，第二小的特征向量提供更具信息性的最佳解决方案。</p>
<p>通过确定随特征值增加的特征向量的连续方向，可将该解推广到寻找最佳$k$维嵌入。在丢弃具有特征值$λ_1=0$的第一平凡特征向量$\overline{e_1}$之后，这导致一组$k$个特征向量$\overline{e_2}，\overline{e_3}…\overline{e_{k+1}}$，相应的特征值$λ_2\leqλ<em>3\leq…\leqλ</em>{k+1} $。每个特征向量的长度为n，并且包含每个节点的一个坐标值。 沿着第$j$个特征向量的第$i$个值代表第$i$个节点的第$j$个坐标。 这创建了一个$n\times k$矩阵，对应于$n$个节点的$k$维嵌入。</p>
<p>小尺度特征向量在新的变换空间中直观地表示什么？通过使用沿小幅度特征向量的节点的排序来创建切口，穿过切口的边缘的重量可能很小。因此，这代表节点空间中的一个集群。在实践中，选择k个最小的特征向量（忽略第一个特征向量）进行缩减并创建k维嵌入。这种嵌入通常包含节点潜在相似结构的极好表示。嵌入可以用于几乎任何基于相似性的应用，尽管这种方法最常见的应用是谱聚类。这种方法的许多变体存在于拉普拉斯算子L如何归一化以及如何生成最终的群集。 谱聚类方法将在第19章第19.3.4节中详细讨论。</p>
<h2 id="2-5-总结"><a href="#2-5-总结" class="headerlink" title="2.5 总结"></a>2.5 总结</h2><p>数据准备是数据挖掘过程的一个重要部分，因为分析算法对输入数据的质量很敏感。 数据挖掘过程需要从各种来源收集原始数据，这些数据可能处于不适合直接应用分析算法的形式。 因此，可能需要应用许多方法才能从基础数据中提取特征。 由此产生的数据可能具有显着的缺失值，错误，不一致性和冗余性。 存在各种分析方法和数据清理工具，用于输入缺失的条目或纠正数据中的不一致性。</p>
<p>另一个重要问题是数据异质性。 分析师可能面临着众多不同的属性，因此数据挖掘算法的直接应用可能并不容易。 因此，数据类型的可移植性很重要，其中一些属性子集被转换为预定义的格式。 由于其简单性，多维格式通常是优选的。 事实上，任何数据类型都可以通过构建相似图的两步过程转换为多维表示，然后是多维嵌入。</p>
<p>数据集可能非常大，并且可能需要在行数和维数方面减小其大小。 使用采样来减少行数是很简单的。 要减少数据中的列数，可以使用特征子集选择或数据转换。 在特征子集选择中，只保留最适合分析的一组较小的特征。 这些方法与分析方法密切相关，因为功能的相关性可能取决于应用程序。 因此，特征选择阶段需要根据特定的分析方法进行调整。</p>
<p>有两种类型的特征转换。 在第一种类型中，可以旋转轴系以与数据的相关性保持一致，并保留方差最大的方向。 第二种类型适用于复杂的数据类型，如图形和时间序列。 在这些方法中，表示的大小减小了，并且数据也被转换为多维表示。</p>
<h2 id="2-6-书目注释"><a href="#2-6-书目注释" class="headerlink" title="2.6 书目注释"></a>2.6 书目注释</h2><p>特征提取的问题对于数据挖掘过程是一个重要的问题，但它具有很高的应用特性。 例如，从文档数据集[400]中提取命名实体的方法与从图像数据集中提取特征的方法[424]非常不同[424]。 [245]中可以找到用于各种领域中的特征提取的一些有前途的技术的概述。</p>
<p>在从不同来源提取功能之后，需要将它们集成到单个数据库中。 传统的数据库文献中描述了很多方法用于数据集成[194,434]。 随后，数据需要清理并且需要删除缺失的条目。 出现了一个概率性或不确定性数据的新领域[18]，它以概率数据库的形式建模了不确定和错误的记录。 然而，这个领域仍处于研究阶段，尚未进入数据库应用的主流。 目前的大多数方法要么使用缺失数据分析的工具[71,364]，要么使用更常规的数据清理和数据清理工具[222,433,435]。</p>
<p>数据清理完毕后，其大小需要根据数量或维数来降低。 最常见和简单的减少数量的方法是采样。 采样方法可用于静态数据集或动态数据集。 传统的数据采样方法在[156]中讨论。 采样方法也已扩展到以油藏采样形式的数据流[35,498]。 [35]中的工作讨论了将油藏采样方法扩展到需要从数据流中创建偏向样本的情况。</p>
<p>特征选择是数据挖掘过程的一个重要方面。 该方法通常高度依赖于正在使用的特定数据挖掘算法。 例如，适用于聚类的特征选择方法可能不适用于分类。 因此，我们将关于特征选择的讨论推迟到本书有关聚类和分类主题的章节。 关于特征选择的主题有很多书[246,336]。</p>
<p>用于多维数据的两种最常见的降维方法是SVD [480,481]和PCA [295]。 这些方法也已扩展到LSA [184,416]形式的文本。 在许多领域[25,184,416]已经表明，使用诸如SVD，LSA和PCA的方法在执行缩减之后出乎意料地提高了底层表示的质量。 这种改进是因为通过丢弃低变量维度来降低噪音影响。 SVD在数据估算中的应用见于[23]和Chap。 本书18。 降维和变换的其他方法包括卡尔曼滤波[260]，Fastmap [202]和非线性方法如拉普拉斯特征映射[90]，MDS [328]和ISOMAP [490]。</p>
<p>近年来还提出了许多降维方法，它们与还原过程一起同时执行类型转换。 这些包括小波变换[475]和图嵌入方法，如ISOMAP和拉普拉斯特征映射[90,490]。 关于图嵌入的谱方法的教程可以在[371]中找到。</p>
<h2 id="2-7-习题"><a href="#2-7-习题" class="headerlink" title="2.7 习题"></a>2.7 习题</h2><ol>
<li><p>考虑时间序列$（-3，-1，1，3，5，7，<em>）$。 这里，缺少的条目用$</em>$表示。在大小为3的窗口上使用线性插值的缺失条目的估计值是多少？</p>
</li>
<li><p>假设你有一堆文本文档，并且你想确定这些文档中提到的所有人物。 你会用什么类别的技术来实现这个目标？</p>
</li>
<li><p>从<em>UCI Machine Learning Repository（UCI机器学习库）</em> [213]下载Arrythmia数据集。将所有记录标准化为平均值0和标准偏差1.将每个数字属性分解为$（a）$10个等宽范围和$（b）$10个等深度范围。</p>
</li>
<li><p>假设你有一组不同类型的任意对象代表不同的小部件特征。 领域专家为您提供每对对象之间的相似度值。 你如何将这些对象转换为一个多维数据集来进行聚类？</p>
</li>
<li><p>假设你有一个数据集，这样每个数据点对应的分辨率为$10×10$平方英里的海面温度。 换句话说，每个数据记录包含具有空间位置的$10×10$个温度值网格。 您还有一些文字与每个$10×10$网格相关联。 你如何将这些数据转换成多维数据集？</p>
</li>
<li><p>假设您有一组离散的生物蛋白质序列，并注明了描述蛋白质特性的文本。 你将如何从这个异构数据集创建一个多维表示？</p>
</li>
<li><p>从<em>UCI Machine Learning Repository</em> [213]下载Musk数据集。 将PCA应用于数据集，并报告特征向量和特征值。</p>
</li>
<li><p>使用<em>SVD</em>重复以前的练习。</p>
</li>
<li><p>对于一个以平均数为中心的数据集$\overline{X_1}…\overline{X_n}$，证明下面结论：<br> $$||\overline{X_i}||^2+||\overline{X_j}||^2=\frac{\sum_{p=1}^n ||\overline{X_i}-\overline{X_p}||^2 }{n}+\frac{\sum_{q=1}^n ||\overline{X_j}-\overline{X_q}||^2 }{n}-\frac{\sum_{p=1}^n \sum_{1=1}^n||\overline{X_p}-\overline{X_q}||^2 }{n^2} \tag{2.22}$$</p>
</li>
<li><p>考虑时间序列1，1，3，3，3，3，1，1.对时间序列执行小波分解。 系列中有多少系数非零？</p>
</li>
<li><p>下载<em>Intel Research Berkeley data set</em>（英特尔研究伯克利）数据集。 对第一个传感器中的温度值应用小波变换。</p>
</li>
<li><p>将来自UCI机器学习库[213]的KDD CUP 1999网络入侵数据集中的每个定量变量作为时间序列来处理。 执行此时间序列的小波分解。</p>
</li>
<li><p>从前一个练习的数据集中创建大小为$n = 1,10,100,1000,10000$个记录的样本，并确定使用该样本的每个定量列$i$的平均值$e_i$。 设$\mu_i$和$\sigma_i$是整个数据集的全局平均值和标准差。 计算$e_i$从$\mu_i$变化的标准偏差$z_i$的数量。<br>$$z_i=\frac{|e_i-\mu_i|}{\sigma_i}$$<br>$z_i$如何随$n$变化？</p>
</li>
<li><p>证明任意0奇异值的奇异向量$\overline{y}$满足$A\overline{y} = 0$。</p>
</li>
<li><p>证明方阵的对角化是<em>SVD</em>的一个特殊变体。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.liyaolife.com/DMtrans1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Li Yao">
      <meta itemprop="description" content="程序员的成长之路| 前端设计&GIS开发 | 图书馆里的扫地僧 少林寺里的清洁工">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yao Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/DMtrans1/" class="post-title-link" itemprop="url">《Data Mining》第1章翻译 绪论</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-06 20:12:30" itemprop="dateCreated datePublished" datetime="2018-05-06T20:12:30+08:00">2018-05-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-14 10:56:34" itemprop="dateModified" datetime="2019-11-14T10:56:34+08:00">2019-11-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1 绪论"></a>1 绪论</h1><!--本章由李尧翻译-->
<blockquote>
<p>“教育不是学习，信息，数据，事实，技能或能力的堆砌,这是培训或教学。教育是让隐藏的种子变得可见。” - Thomas More</p>
</blockquote>
<h2 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h2><p>数据挖掘是收集，清理，处理，分析和从数据中获得有用见解的研究。 在实际应用中遇到的问题域，应用，公式和数据表示方面存在很大差异。 因此，“数据挖掘”是一个广泛的术语，用于描述数据处理的这些不同方面。</p>
<p>在现代，几乎所有的自动化系统都会生成某种形式的数据，用于诊断或分析目的。 这导致了大量的数据，这些数据已达到PB或EB的数量级。 不同类型数据的一些例子如下：</p>
<ul>
<li>万维网：编入搜索引擎索引的网站已经超过十亿，而不可见的网络要大得多。 用户访问这些文档可以在服务器上创建Web访问日志，并在商业网站上创建客户行为文档。 此外，Web的链接结构被称为Web图，它本身就是一种数据。 这些不同类型的数据在各种应用中很有用。 例如，可以挖掘Web文档和链接结构来确定Web上不同话题之间的关联。 另一方面，可以挖掘用户访问日志以确定频繁的访问模式或可能不必要的行为的不寻常模式。</li>
<li>财务交互：日常生活中最常见的交易，例如使用自动取款机（ATM）卡或信用卡，可以自动创建数据。 这种交易可以挖掘许多有用的见解，例如欺诈或其他不寻常的活动。</li>
<li>传感器技术和物联网：最近的趋势是开发低成本的可穿戴传感器，智能手机和其他可相互通信的智能设备。 据估计，2008年这类设备的数量超过了这个星球上的人数。这种海量数据收集的影响对于挖掘算法是非常重要的。</li>
</ul>
<p>数据的泛滥是科技进步和现代生活各个方面电脑化的直接结果。 因此，检查一个人是否可以从可用数据中为特定应用目标提取简明而可行的见解是自然而然的。 这就是数据挖掘任务的来源。原始数据可能是任意的，非结构化的，甚至是不适合自动处理的格式。 例如，手动收集的数据可能来自不同格式的异构数据源，但不知何故需要通过自动化计算机程序进行处理以获取见解。</p>
<p>为了解决这个问题，数据挖掘分析人员使用一系列处理流程，将原始数据收集，清理并转换为标准格式。 数据可以存储在商业数据库系统中，并通过使用分析方法进行最终处理。 实际上，尽管数据挖掘经常让人联想到分析算法的概念，但事实是绝大多数工作都与流程的数据准备部分有关。 这种处理流程在概念上类似于从矿石到最终产品的实际采矿过程。 “采矿”一词源于此类推。</p>
<p>从分析的角度来看，数据挖掘具有挑战性，因为遇到的问题和数据类型存在很大差异。例如，即使在输入数据格式或问题定义层面，商业产品推荐问题与入侵检测应用程序的差异也很大。即使在相关的问题类别中，这些差异也是非常重要的。例如，由于底层数据类型的差异，多维数据库中的产品推荐问题与社交推荐问题差异很大。然而，尽管存在这些差异，数据挖掘应用通常与数据挖掘中的四个“超级问题”之一紧密相关：关联模式挖掘，聚类，分类和异常值检测。这些问题非常重要，因为它们在大多数应用程序中以间接形式或其他形式用作构建块。这是一个有用的抽象概念，因为它有助于我们更有效地概念化和构建数据挖掘领域。</p>
<p>数据可能有不同的格式或类型。 类型可以是定量的（例如年龄），分类的（例如种族），文本，空间的，时间的或面向图的。 虽然最常见的数据形式是多维的，但是越来越多的数据属于更复杂的数据类型。 尽管很多数据类型之间的算法在概念上具有很高的可移植性，但从实际角度来看并非如此。 现实情况是，精确的数据类型可能会显着影响特定算法的行为。 因此，可能需要为多维数据设计基本方法的精确变化，以便它可以有效地用于不同的数据类型。 因此，本书将为各种数据类型分配不同的章节，以更好地理解处理方法受基础数据类型影响的方式。</p>
<p>由于数据量的增加，近年来出现了一个重大挑战。 连续收集的数据流行使人们对数据流领域的兴趣日益增加。 例如，互联网传输会产生大量的数据流，除非将大量资源用于存储，否则无法有效存储。 从处理和分析的角度来看，这导致了独特的挑战。 在无法明确存储数据的情况下，所有处理都需要实时执行。</p>
<p>本章将对预处理和分析不同类型数据所涉及的不同技术进行全面概述。 目标是从经常遇到的不同问题抽象和数据类型的角度研究数据挖掘。 许多重要的应用程序可以转换为这些抽象。</p>
<p>本章安排如下。 第1.2节讨论数据挖掘过程，特别关注本节中的数据预处理阶段。不同的数据类型及其正式的定义在第1.3节讨论。数据挖掘中的主要问题在第1.4节中有深入的讨论。 本部分还讨论了数据类型对问题定义的影响。 可扩展性问题在第1.5节里讨论。 第1.6节，提供了一些应用程序的例子。第1.7节给出了一个总结。</p>
<p>##1.2 数据挖掘过程</p>
<p>如前所述，数据挖掘过程是一个包含许多阶段的管道，如数据清理，特征提取和算法设计。 在本节中，我们将研究这些不同阶段。 典型数据挖掘应用程序的工作流程包含以下阶段：</p>
<ol>
<li><p>数据收集：数据收集可能需要使用专用硬件，如传感器网络，手工劳动（如收集用户调查）或软件工具（如Web文档抓取引擎）来收集文档。 虽然这个阶段的应用程序具有高度特异性，并且常常超出数据挖掘分析师的范畴，但这一点至关重要，因为在此阶段的良好选择可能会显着影响数据挖掘过程。 收集阶段之后，数据通常存储在数据库中，或者更一般地存储在数据仓库中进行处理。</p>
</li>
<li><p>特征提取和数据清洗：收集数据时，通常不会采用适合处理的形式。例如，数据可能以复杂日志或自由格式文档编码。在许多情况下，不同类型的数据可以任意混合在一起形成自由格式的文件。为了使数据适合处理，必须将它们转换为对数据挖掘算法（如多维，时间序列或半结构化格式）友好的格式。多维格式是最常见的格式，其中数据的不同字段与被称为特征，属性或维度的不同测量属性相对应。为采矿过程提取相关特征至关重要。特征提取阶段通常与数据清理并行执行，其中估计或校正缺失和错误的数据部分。在很多情况下，数据可能从多个来源提取，需要整合到一个统一的格式中进行处理。这个过程的最终结果是一个很好的结构化数据集，它可以被计算机程序有效地使用。在特征提取阶段之后，数据可以再次被存储在数据库中以供处理。</p>
</li>
<li><p>分析过程与算法： 数据挖掘的最后一步是从处理过的数据中设计出有效的分析方法。在很多情况下，可能无法直接使用标准的数据挖掘问题，例如前面讨论的四个“超级问题”，以用于手头的应用程序。 但是，这四个问题的覆盖范围很广，许多应用程序可以分解为使用这些不同构建模块的组件。 这本书将提供这个过程的例子。<br><img src="http://p6atp7tts.bkt.clouddn.com/15249000172922.jpg" alt=""></p>
<center>图1.1 数据处理流程</center>

</li>
</ol>
<p>整个数据挖掘过程如图1.1所示。 请注意，图1.1中的分析块显示了代表特定应用解决方案设计的多个构建块。 算法设计的这一部分取决于分析师的技能，并经常将四个主要问题中的一个或多个作为构建块。 当然，情况并非总是如此，但在本书中，对这四个问题进行特殊处理已经足够频繁了。 为了解释数据挖掘过程，我们将使用推荐场景中的一个示例。</p>
<p><strong>例1.2.1</strong>  <em>考虑一个零售商拥有与客户访问其网站上的网页相对应的Web日志的情景。 这些网页中的每一个都与产品相对应，因此客户访问页面通常可能表明对该特定产品感兴趣。 零售商还为不同的顾客存储人口统计资料。 零售商希望使用客户人口统计和购买行为向客户提供有针对性的产品推荐。</em></p>
<p><strong>解决方案</strong> 在这种情况下，分析师的第一步是收集来自两个不同来源的相关数据。 第一个来源是该网站上的一组Web日志。 第二个是零售商数据库中的人口统计信息，这些信息是在客户的Web注册期间收集的。 不幸的是，这些数据集的格式非常不同，不能一起用于处理。 例如，请考虑以下表单的示例日志条目：</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">98.206.207.157</span> - - <span class="string">[31/Jul/2013:18:09:38 -0700]</span> <span class="string">"<span class="keyword">GET</span> /productA.htm HTTP/1.1"</span> <span class="number">200</span> <span class="number">328177</span> <span class="string">"-"</span> <span class="string">"Mozilla/5.0 (Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/6.0 Mobile/10B329 Safari/8536.25"</span> <span class="string">"retailer.net"</span></span><br></pre></td></tr></table></figure>
<p>日志可能包含数十万个这样的条目。 在此，IP地址为98.206.207.157的客户已访问productA.htm。 IP地址的客户可以使用以前的登录信息，Cookie或IP地址本身进行识别，但这可能是一个嘈杂的过程，并不一定会产生准确的结果。 分析师需要设计算法来决定如何过滤不同的日志条目，并只使用那些提供准确结果的算法作为清理和提取过程的一部分。此外，原始的日志中包含很多附加信息，这些信息对零售商不一定有用。在特征提取过程中，零售商决定为每个客户创建一条记录，并从网页访问中提取特征的特定选择。 对于每个记录，属性对应于每个产品说明的访问次数。 因此，需要处理原始日志，并且在此特征提取阶段需要对访问进行汇总。 在数据集成阶段，零售商的数据库中的属性被添加到这些包含人口统计信息的记录中。 需要估计人口统计记录中缺少的条目以进一步清理数据。 这导致包含客户人口统计和客户访问属性的单个数据集。</p>
<p>在这一点上，分析师必须决定如何使用这个清理过的数据集来提出建议。 他或她决定确定类似的顾客群，并根据这些类似群体的购买行为提出建议。 特别是，聚类的构建块用于确定类似的组。 对于给定的客户，推荐该组中的客户访问的频率最高的项目。 这提供了整个数据挖掘管道的一个例子。 我们将在第18章讨论，有很多优雅的方法来执行这些建议，其中一些比其他方法更有效，具体取决于问题的具体定义。 因此，整个数据挖掘过程是一种艺术形式，它基于分析师的技能，无法通过单一技术或构建块完全捕获。 在实践中，只有通过针对不同场景和数据类型的各种应用程序才能学习此技能。</p>
<h3 id="1-2-1-数据预处理阶段"><a href="#1-2-1-数据预处理阶段" class="headerlink" title="1.2.1 数据预处理阶段"></a>1.2.1 数据预处理阶段</h3><p>数据预处理阶段可能是数据挖掘过程中最关键的阶段。 然而，由于大部分重点都放在数据挖掘的分析方面，所以很少进行探讨。 这个阶段在收集数据之后开始，它由以下步骤组成：</p>
<ol>
<li><p>特征提取：分析人员可能面临大量的原始文档，系统日志或商业事务，而很少有关于如何将这些原始数据转换为有意义的数据库特征进行处理的指导。 此阶段高度依赖于分析师能够抽象出与特定应用程序最相关的功能。 例如，在信用卡欺诈检测应用程序中，收费金额，重复频率和地点往往是欺诈的良好指标。 但是，许多其他功能可能是较差的欺诈指标。 因此，提取正确的特征通常是需要了解特定应用领域的技巧。</p>
</li>
<li><p>数据清理：提取的数据可能有错误或缺失的条目。 因此，可能需要删除一些记录，或者可能需要估计缺失的条目。 不一致可能需要删除。</p>
</li>
<li><p>特征选择和转换：当数据维度非常高时，许多数据挖掘算法无法有效地发挥作用。 此外，许多高维特征都很嘈杂，可能会给数据挖掘过程增加错误。 因此，使用各种方法来删除不相关的功能或将当前功能集转换为更适合分析的新数据空间。 另一个相关的方面是数据转换，其中具有一组特定属性的数据集可以被转换为具有相同或不同类型的另一组属性的数据集。 例如，可以将诸如年龄之类的属性划分为范围以创建离散值以用于分析便利。</p>
</li>
</ol>
<p>数据清理过程需要通常用于缺失数据估计的统计方法。 另外，通常会删除错误的数据条目以确保更准确的挖掘结果。关于数据清洗的部分在第2章数据预处理部分会再涉及。</p>
<p>特征选择和转换不应被视为数据预处理的一部分，因为特征选择阶段往往高度依赖于正在解决的特定分析问题。 在某些情况下，特征选择过程甚至可以以包装模型或嵌入模型的形式与所使用的特定算法或方法紧密集成。 尽管如此，特征选择阶段通常在应用特定算法之前执行。</p>
<p>###1.2.2 分析阶段<br>本书的绝大多数内容将专注于挖掘过程的分析阶段。 一个主要的挑战是每个数据挖掘应用程序都是独一无二的，因此很难在不同的应用程序中创建通用和可重用的技术。 尽管如此，许多数据挖掘配方在不同的应用环境中被重复使用。 这些对应于数据挖掘过程的主要“超级问题”或构件。 这取决于分析人员的技能和经验，以确定如何在特定的数据挖掘应用环境中使用这些不同的公式。 尽管本书可以对基础数据挖掘模型提供一个很好的概述，但是将它们应用于实际应用程序的能力只能通过实践经验来学习。</p>
<p>##1.3 基本数据类型<br>数据挖掘过程的一个有趣的方面是可用于分析的各种数据类型。 对于数据挖掘过程，有两种广泛类型的数据，具有不同的复杂性：</p>
<ol>
<li><p>无依赖性的数据：这通常指的是简单的数据类型，如多维数据或文本数据。 这些数据类型是最简单和最常遇到的。 在这些情况下，数据记录在数据项或属性之间没有任何特定的依赖关系。 一个例子是关于包含年龄，性别和邮政编码的个人的一组人口统计记录。</p>
</li>
<li><p>依赖于数据的数据：在这些情况下，数据项之间可能存在隐式或显式关系。 例如，社交网络数据集包含通过一组边（关系）连接在一起的一组顶点（数据项）。 另一方面，时间序列包含隐式依赖关系。 例如，从传感器采集的两个连续值可能彼此相关。 因此，时间属性隐含指定了连续读数之间的依赖关系。</p>
</li>
</ol>
<p>一般而言，由于数据项之间已有的关系所产生的复杂性，依赖性数据更具挑战性。 数据项之间的这种依赖关系需要直接纳入分析过程，以获得具有上下文意义的结果。</p>
<p><center>表1.1 多维数据集的一个例子</center><br><img src="http://p6atp7tts.bkt.clouddn.com/15249001649310.jpg" alt=""></p>
<p>###1.3.1 无依赖性的数据<br>这是最简单的数据形式，通常指的是多维数据。 这些数据通常包含一组记录。 根据手头的应用程序，记录也被称为数据点，实例，示例，事务，实体，元组，对象或特征向量。 每条记录都包含一组字段，这些字段也称为属性，维度和功能。 这些术语在本书中将互换使用。 这些字段描述了该记录的不同属性。 关系数据库系统传统上被设计为处理这种数据，即使是最早的形式。 例如，考虑表1.1中所示的人口统计数据集。 在此，说明了个人的人口统计特征，例如年龄，性别和邮政编码。 多维数据集定义如下：</p>
<p><strong>定义 1.3.1（多维数据）</strong>  <em>一个多维数据集$D$，包含$n$个记录，$\overline{X_1}…\overline{X_n}$，其中每个记录$\overline{X_i}$包含一系列特征记作$(x^1_i…x^d_i)$</em>。</p>
<p>在本书的前几章中，我们将使用多维数据，因为它是最简单的数据形式，并建立了可以处理更复杂的数据类型的更广泛的原则。 本书后面的章节将讨论更复杂的数据类型，并明确讨论依赖关系对挖掘过程的影响。</p>
<h4 id="1-3-1-1-定量多维数据"><a href="#1-3-1-1-定量多维数据" class="headerlink" title="1.3.1.1 定量多维数据"></a>1.3.1.1 定量多维数据</h4><p>表1.1中的属性有两个不同的类型。年龄字段具有数值，因为它们具有自然顺序。这些属性被称为连续的，数字的或定量的。所有字段都是定量的数据也称为定量数据或数字数据。因此，当定义1.3.1中的$x^j_i$的每一个值都是定量的时候，相应的数据集被称为定量多维数据集。在数据挖掘文献中，这种特定的数据子类型被认为是最常见的，本书讨论的许多算法都适用于这种数据子类型。这个子类型对于分析处理特别方便，因为从统计的角度来看，处理定量数据要容易得多。 例如，一组定量记录的平均值可以表示为这些值的简单平均值，而此类计算在其他数据类型中变得更加复杂。 在可能和有效的情况下，许多数据挖掘算法因此试图在处理之前将不同类型的数据转换为定量值。 这也是这个（或者几乎任何其他）数据挖掘教科书中讨论的许多算法假设定量多维表示的原因。 尽管如此，在实际应用中，数据可能更加复杂，可能包含不同数据类型的混合。</p>
<h4 id="1-3-1-2-分类和混合属性数据"><a href="#1-3-1-2-分类和混合属性数据" class="headerlink" title="1.3.1.2 分类和混合属性数据"></a>1.3.1.2 分类和混合属性数据</h4><p>实际应用中的许多数据集可能包含采用离散无序值的分类属性。例如，在表1.1中，诸如性别，种族和邮政编码等属性具有离散值，其中没有自然顺序。如果定义1.3.1中$x^j_i$的每个值都是分类的，那么这些数据被称为无序离散值或分类。在混合属性数据的情况下，存在分类属性和数字属性的组合。表1.1中的完整数据被视为混合属性数据，因为它们包含数字属性和分类属性。</p>
<p>与性别相对应的属性是特殊的，因为它是分类的，但只有两个可能的值。在这种情况下，可以在这些值之间施加人工排序，并使用针对此类数字数据设计的算法。这被称为二进制数据，它可以被认为是数字或分类数据的特例。第一章。 2将解释二进制数据如何形成“桥梁”以将数字或分类属性转换为适合在许多情况下处理的通用格式</p>
<h4 id="1-3-1-3-二进制和设置数据"><a href="#1-3-1-3-二进制和设置数据" class="headerlink" title="1.3.1.3 二进制和设置数据"></a>1.3.1.3 二进制和设置数据</h4><p>二元数据可以被认为是多维分类数据或多维定量数据的特例。 它是多维分类数据的一个特例，其中每个分类属性可以采用最多两个离散值中的一个。 这也是多维定量数据的特例，因为两个值之间存在排序。 此外，二进制数据也是setwise数据的表示形式，其中每个属性都被视为集合元素指示符。 值为1表示该元素应该包含在集合中。 这些数据在市场购物篮应用中很常见。在第4章和第5章，将详细讨论这个话题。</p>
<h4 id="1-3-1-4-文本数据"><a href="#1-3-1-4-文本数据" class="headerlink" title="1.3.1.4 文本数据"></a>1.3.1.4 文本数据</h4><p>文本数据可以视为字符串，也可以视为多维数据，具体取决于它们的表示方式。 在其原始形式中，文本文档对应于一个字符串。 这是一个面向依赖性的数据类型，将在本章后面介绍。 每个字符串都是与文档对应的一系列字符（或字）。 但是，文本文档很少以字符串表示。 这是因为直接使用大规模应用程序中有效方式的单词之间的排序是很困难的，并且利用排序的其他优势在文本域中经常受到限制。</p>
<p>实际上，使用矢量空间表示法，文档中单词的频率用于分析。 单词有时也被称为术语。 因此，在这种表示中，单词的精确排序是丢失的。 这些频率通常用诸如文档长度或集合中单个单词的频率之类的统计数据标准化。这些关于文本数据的事件将在第13中有较详细的讨论。具有$n$个文档和$d$项的文本集合对应的$n \times d$数据矩阵被称为文档项矩阵。</p>
<p>当以向量空间形式表示时，文本数据可以被认为是多维定量数据，其中属性对应于这些词，并且这些值对应于这些属性的频率。 然而，这种量化数据是特殊的，因为大多数属性都取零值，只有少数属性具有非零值。 这是因为单个文档可能只包含大小为$10^5$的字典中的相对少量的单词。 这种现象被称为数据稀疏性，它显着影响数据挖掘过程。如果没有采取合适的适配措施，直接采用定量数据的挖掘算法在稀疏数据上可能达不到想要的效果。同时，稀疏性还影响着数据的表现方式。比如，例如，虽然可以使用定义1.3.1中提出的表示法，但这不是一种实际的方法。对于文本数据，定义1.3.1中的大多数$x^i_j$值都是0。对于文本数据，定义1.3.1中的大多数$x^i_j$值都是0。使用包含词语的表示仅包含文档中的词语。 另外，这些词的频率被明确地保持。 这种方法通常更有效。 由于数据稀疏性问题，文本数据通常使用专门的方法进行处理。因此，文本挖掘通常作为数据挖掘中的一个单独的子主题进行研究。 文本挖掘方法在第13章讨论。</p>
<p>###1.3.2 有依赖性的数据<br>本章中大多数前面讨论的内容都是关于多维场景，其中假定可以独立处理数据记录。 实际上，不同的数据值可能（隐含地）在时间上，空间上或者通过数据项之间的显式网络关系链接彼此相关。 关于先前存在的依赖关系的知识大大改变了数据挖掘过程，因为数据挖掘都是关于发现数据项之间的关系。 因此，先前存在的依赖关系会改变数据中的预期关系，并从这些预期关系的角度来看可能会引起人们的兴趣。 可能存在几种可能是隐式或显式的依赖关系：</p>
<ol>
<li><p>隐式依赖关系：在这种情况下，数据项之间的依赖关系没有明确指定，但已知“典型”存在于该域中。 例如，由传感器收集的连续温度值可能彼此非常相似。 因此，如果传感器在特定时间记录的温度值与下一时刻记录的温度值显着不同，那么这非常不寻常，可能对数据挖掘过程有意义。 这与多维数据集不同，其中每个数据记录都被视为一个独立的实体。</p>
</li>
<li><p>显式依赖关系：这通常指的是使用边来指定显式关系的图或网络数据。 图是非常强大的抽象，通常用作中间表示来解决其他数据类型环境中的数据挖掘问题。</p>
</li>
</ol>
<p>在本节中，将详细讨论不同的依赖性数据类型。</p>
<p>####1.3.2.1 时间序列数据<br>时间序列数据包含通常通过连续测量随时间推移而生成的值。 例如，环境传感器将连续测量温度，而心电图（ECG）将测量受试者心律的参数。 这样的数据通常具有隐含的依赖性，这些隐含的依赖性随着时间的推移被接收到。 例如，温度传感器记录的相邻值通常会随着时间的推移而平稳变化，这个因素需要在数据挖掘过程中明确使用。</p>
<p>时间依赖性的性质可能与应用程序显着不同。 例如，某些形式的传感器读数可能会随时间显示测量属性的周期性模式。时间序列挖掘的一个重要方面是提取数据中的这种依赖关系。 为了形式化由时间相关引起的依赖问题，属性被分为两类：</p>
<ol>
<li><p>上下文属性：这些属性用于定义隐式依赖关系发生在数据上的上下文。 例如，在传感器数据的情况下，测量读数的时间戳可以被认为是上下文属性。 有时，时间戳未被明确使用，但是使用位置索引。 虽然时间序列数据类型只包含一个上下文属性，但其他数据类型可能具有多个上下文属性。 一个具体的例子是空间数据，这将在本章后面讨论。</p>
</li>
<li><p>行为属性：它们表示在特定上下文中衡量的值。 在传感器示例中，温度是行为属性值。 可能有多个行为属性。 例如，如果多个传感器在同步时间戳上记录读数，则它会产生多维时间序列数据集。</p>
</li>
</ol>
<p>上下文属性通常会对数据中行为属性值之间的依赖关系产生强烈影响。 形式上，时间序列数据定义如下：</p>
<p><strong>定义 1.3.2（多元时间序列数据）</strong> <em>一个长度为$n$，维度为$d$的时间长度序列包含$d$个数字特征，每个数字特征中包含$n$个时间戳$t_1..t_n$。每个时间戳包含每个$d$系列的组件。因此，$t_1$时刻对应的数据集是$\overline{Y_i}=(y^1_i…y^d_i)$。在$t_i$时刻的第$j$个序列是$y^j_i$。</em></p>
<p>例如，考虑一个特定位置的两个传感器每分钟监测一次温度和压力的情况。这对应于一个$d=2$，$n=60$的一个多维序列。在一些情况下，时间戳$t_1…t_n$可能会被序列值1到$n$代替，特别是当时间戳的值等距离间隔时（比如本例子中每秒取一个）。</p>
<p>时间序列数据在许多传感器应用，预测和金融市场分析中都比较常见。 分析时间序列的方法在第14章中讨论。</p>
<h4 id="1-3-2-2-离散序列和字符串"><a href="#1-3-2-2-离散序列和字符串" class="headerlink" title="1.3.2.2 离散序列和字符串"></a>1.3.2.2 离散序列和字符串</h4><p>离散序列可以被认为是时间序列数据的分类模拟。 就时间序列数据而言，上下文属性是排序中的时间戳或位置索引。 行为属性是一个分类值。 因此，离散序列数据的定义与时间序列数据类似。</p>
<p><strong>定义 1.3.3（多元离散序列数据）</strong> <em>一个长度为$n$，维度为$d$的离散序列包含$d$个离散特征，每个离散特征中包含$n$个时间戳$t_1..t_n$。$n$个部分中的每个$\overline{Y_i}$包含$d$个离散行为属性，在第i个时间戳时，这d个行为属性表示为$\overline{Y_i}=(y^1_i…y^d_i)$</em></p>
<p>例如，考虑一系列Web访问，其中收集100个不同访问的Web页面地址和请求的源IP地址。 这表示长度n = 100和维度d = 2的离散序列。序列数据中特别常见的情况是单变量方案，其中d的值是1.这样的序列数据也称为字符串。</p>
<p>应该指出的是，上述定义与时间序列情况几乎相同，主要差异在于离散序列包含分类属性。 从理论上讲，有可能在分类和数字数据之间混合使用一系列数据。 另一个重要的变体是一个序列不包含分类属性的情况，而是一组任意数量的无序分类值。 例如，超市交易可能包含一系列项目。 每套可能包含任何数量的项目。 这种序列序列并不是真正的多变量序列，而是单变量序列，其中序列的每个元素都是一个集合，而不是单位元素。 因此，与时间序列数据相比，离散序列可以以更多种方式定义，因为能够定义离散元素上的集合。</p>
<p>在某些情况下，上下文属性可能不会明确地指明时间，但它可能是基于物理位置的位置。 生物序列数据就是这种情况。 在这种情况下，时间戳可以用表示字符串中值的位置的索引代替，将最左边的位置计为1.可能出现序列数据的常见情景的一些示例如下：</p>
<ul>
<li>事件日志：各种计算机系统，Web服务器和Web应用程序根据用户活动创建事件日志。 事件日志的一个例子是金融网站上的一系列用户操作：  <figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Login Password Login Password Login Password ....</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这个特定的序列可能代表用户试图进入密码保护系统的场景，从异常检测的角度来看，这可能很有趣。</p>
<ul>
<li>生物学数据：在这种情况下，序列可对应于核苷酸或氨基酸的串。 这些单位的排序提供了有关蛋白质功能特征的信息。 因此，数据挖掘过程可以用来确定有趣的模式，反映不同的生物特性。</li>
</ul>
<p>离散序列对于挖掘算法通常更具挑战性，因为它们没有时间序列数据的平滑值连续性。关于序列挖掘的方法，将在第15章有更详细的讨论。</p>
<p>1.3.2.3 空间数据<br>在空间数据中，在空间位置处测量许多非空间属性（例如，温度，压力，图像像素颜色强度）。 例如，气象学家经常收集海面温度来预测飓风的发生。 在这种情况下，空间坐标对应于上下文属性，而诸如温度的属性对应于行为属性。 通常，有两个空间属性。 就时间序列数据而言，也可以具有多个行为属性。 例如，在海面温度应用中，人们也可以测量其他行为属性，如压力。</p>
<p><strong>定义 1.3.4（空间数据）</strong> <em>$d$维空间数据记录包含d个行为属性和一个或多个包含空间位置的上下文属性。因此，一个$d$维空间数据集应该包含一个$d$维记录集$\overline{X_1}…\overline{X_n}$，同时还包含一个位置的集合$L_1…L_n$，并且记录$\overline{X_i}$和位置$L_i$是关联在一起的。</em></p>
<p>上述定义在如何定义记录$\overline{X_i}$和位置$L_i$方面提供了广泛的灵活性。 例如，记录$\overline{X_i}$中的行为属性可能是数字或分类的，或者是两者的混合。在气象应用中，$X_i$可能包含位置$L_i$处的温度和压力属性。此外，可以根据精确的空间坐标（如纬度和经度）或逻辑位置（如城市或州）来指定$L_i$。</p>
<p>空间数据挖掘与时间序列数据挖掘密切相关，因为大多数研究空间应用程序中的行为属性是连续的，尽管一些应用程序也可能使用分类属性。 因此，在连续的空间位置观察到价值连续性，就像在时间序列数据中连续的时间戳中观察到的价值连续性一样。</p>
<p><strong>时空数据</strong><br>空间数据的一种特殊形式是空间时间数据，其包含空间和时间属性。 数据的确切性质还取决于哪些属性是上下文的，哪些属性是行为的。 两种时空数据是最常见的：</p>
<ol>
<li><p>空间属性和时间属性都是上下文的：这种数据可以被看作是空间数据和时间数据的直接推广。 当同时测量特定行为属性的空间和时间动态时，这种数据特别有用。 例如，考虑需要随时间测量海面温度变化的情况。 在这种情况下，温度是行为属性，而空间和时间属性是上下文相关的。</p>
</li>
<li><p>时间属性是上下文的，而空间属性是行为的：严格地说，这种数据也可以被认为是时间序列数据。 然而，行为属性的空间性质在许多情况下也提供了更好的解释性和更集中的分析。 这些数据的最常见形式来自轨迹分析。</p>
</li>
</ol>
<p>应该指出的是，任何2维或3维时间序列数据都可以映射到轨迹上。 这是一个有用的转换，因为它意味着轨迹挖掘算法也可以用于2维或3维时间序列数据。 例如，英特尔研究伯克利数据集[556]包含来自各种传感器的读数。 图1和图2中示出了来自温度和电压传感器的一对读数的示例。 1.2a和b，分别。 相应的温度 - 电压轨迹如图1.2c所示。 有关空间和时空数据挖掘的方法将在第7章讨论。16。</p>
<p>####1.3.2.4 网络和图数据<br>在网络和图形数据中，数据值可以对应于网络中的节点，而数据值之间的关系可以对应于网络中的边缘。 在某些情况下，属性可能与网络中的节点相关联。 虽然也可以将属性与网络中的边相关联，但这样做通常要少得多。</p>
<p><strong>定义 1.3.5（网路数据）</strong> <em>一个网络$G=(N,A)$包含一系列节点$N$和一系列边$A$，$A$中的边代表了节点之间的关系。在某些情况下，一个属性集$\overline{X_i}$可能和节点$i$联系在一起，同理一个属性集$\overline{Y_{ij}}$可能和边$(i,j)$联系在一起。</em></p>
<p>边$（i，j）$可以是有向或无向的，这取决于当前的应用。 例如，Web图可能包含与页面之间的超链接方向相对应的有向边，而Facebook社交网络中的好友关系不受引导。</p>
<p>第二类图挖掘问题是包含许多小图的数据库，例如化合物。 这两类问题的挑战是非常不同的。 以图形表示的数据的一些示例如下所示：</p>
<ul>
<li><p>网络图：节点对应于网页，边对应于超链接。 节点具有与页面中的内容相对应的文本属性。</p>
</li>
<li><p>社交网络：在这种情况下，节点对应于社交网络参与者，而边缘对应于友谊链接。 节点可以具有对应于社交页面内容的属性。在一些特殊形式的社交网络中，例如电子邮件或聊天信使网络，边缘可能有与其相关的内容。 该内容对应于不同节点之间的通信。</p>
</li>
<li><p>化合物数据库：在这种情况下，节点对应于元素，边对应于元素之间的化学键。 这些化合物中的结构对于鉴定这些化合物的重要反应性和药理学性质非常有用。</p>
</li>
</ul>
<p>网络数据是一种非常普遍的表示形式，可用于解决其他数据类型上的许多基于相似性的应用程序。 例如，可以通过为数据库中的每个记录创建一个节点并通过边表示节点之间的相似性，将多维数据转换为网络数据。 这种表示经常用于许多基于相似性的数据挖掘应用程序，例如聚类。可以使用社区检测算法来确定网络数据中的群集，然后将其映射回多维数据。 第19章讨论的一些谱聚类方法基于这个原理。 网络数据的这种普遍性是有代价的。 网络数据挖掘算法的开发通常比较困难。 第17章，第18章和第19章讨论了挖掘网络数据的方法。</p>
<p>##1.4 主要构件：鸟瞰图<br>正如引言第1.1节所述，数据挖掘中的四个问题被认为是挖掘过程的基础。 这些问题对应于聚类，分类，关联模式挖掘和异常值检测，并且它们在许多数据挖掘应用程序的环境中反复遇到。 是什么让这些问题如此特别？ 他们为什么重复遭遇？ 要回答这些问题，必须了解数据科学家经常试图从数据中提取的典型关系的性质。</p>
<p>考虑具有$n$个记录和$d$个属性的多维数据库$D$. 这样的数据库$D$可以被表示为$n \times d$矩阵$D$，其中每行对应于一条记录，并且每列对应于一个维度。 我们通常将这个矩阵称为数据矩阵。 本书将交替使用数据矩阵$D$和数据库$D$的符号。 一般来说，数据挖掘都是关于发现数据矩阵中条目之间的总结关系，这些关系要么非常频繁，要么非常罕见。 数据项之间的关系是两种类型之一：</p>
<ul>
<li><p>列之间的关系：在这种情况下，确定特定行中值之间的频繁关系或不频繁关系。 这映射到正面或负面的关联模式挖掘问题，尽管前者更常被研究。 在某些情况下，矩阵的一个特定列被认为比其他列更重要，因为它表示数据挖掘分析师的目标属性。 在这种情况下，我们试图确定其他列中的关系如何与此特殊列关联。 当特殊列的值未知时，可以使用这种关系来预测此特殊列的值。 这个问题被称为数据分类。 当挖掘过程基于将特定属性视为特殊属性并对其进行预测时，它被称为受监督的。</p>
</li>
<li><p>行之间的关系：在这些情况下，目标是确定行的子集，其中相应列中的值是相关的。 在这些子集相似的情况下，相应的问题被称为聚类。另一方面，当一行中的条目与其他行中的相应条目非常不同时，那么相应的行就会变成有趣的异常数据点或异常。这个问题被称为异常值分析。有趣的是，聚类问题与分类密切相关，因为后者可以被认为是前者的监督版本。数据中特殊列的离散值对应于数据中不同期望或监督的应用程序特定相似记录组的组标识符。例如，当专栏对应于客户是否对某一特定产品感兴趣时，这代表了在有兴趣学习的数据中使用监督的两个小组。术语“监督”指的是这样一个事实，即专门专栏用于以特定应用程序的方式指导数据挖掘过程，就像教师可以监督他或她的学生实现特定目标一样。</p>
</li>
</ul>
<p>因此，这四个问题很重要，因为它们似乎涵盖了表示数据矩阵条目之间不同种类的正面，负面，监督或无监督关系的详尽情景。 这些问题也以各种方式相互关联。 例如，关联模式可以被认为是（重叠的）簇的间接表示，其中每个模式对应于它是其子集的数据点的簇。</p>
<p>应该指出，上述讨论假定（最常遇到的）多维数据类型，尽管这些问题继续保留它们对于更复杂数据类型的相对重要性。 但是，更复杂的数据类型由于其更复杂而具有更多种与其相关的问题表达式。 这个问题将在本节后面详细讨论。</p>
<p>一直观察到，许多应用场景确定数据矩阵的行和列之间的这种关系作为中间步骤。 这就是理解这些构件块问题对数据挖掘过程如此重要的原因。 因此，本书的第一部分将在将其推广到复杂场景之前将重点详细讨论这些问题。</p>
<p>###1.4.1 关联模式挖掘<br>在其最原始的形式中，关联模式挖掘问题被定义在稀疏二进制数据库的上下文中，其中数据矩阵仅包含$0/1$条目，并且大多数条目的值为0。大多数客户事务数据库是这种类型的。 例如，如果数据矩阵中的每列对应一个项目，并且客户交易表示一行，则第$（i，j）$项为1，如果客户交易i包含项目j作为购买的项目之一。 这个问题特别常见的研究版本是频繁模式挖掘问题，或者更一般地说，关联模式挖掘问题。 就二进制数据矩阵而言，频繁模式挖掘问题可以正式定义如下：</p>
<p><strong>定义 1.4.1（频率模式挖掘）</strong> <em>给定一个二元$n \times d$数据矩阵$D$，确定列的所有子集，使得这些列中的所有值对于矩阵中的至少一小部分行取值1。 模式的相对频率被称为它的支持。分数$s$被称为最小支持。</em></p>
<p>满足最低支持要求的模式通常被称为频繁模式或频繁项目集。 频繁模式代表了一类重要的关联模式。许多其他相关关联模式的定义可能不使用绝对频率，但使用其他统计量化，如$X^2$度量。这些措施往往导致从统计角度产生更有趣的规则。 尽管如此，关联模式挖掘的这种特殊定义已经成为文献中最流行的定义，因为它易于开发算法。 因此，本书将此问题称为关联模式挖掘，而不是频繁模式挖掘。</p>
<p>例如，如果对应于面包，黄油和牛奶的数据矩阵$D$的列在客户交易数据库中经常一起取值1，则这意味着这些项目经常被一起购买。 从商店内商品的实物放置角度或从产品促销的角度来看，这对商家来说非常有用。 关联模式挖掘不限于二进制数据的情况，并且可以通过使用适当的数据转换容易地推广到定量和数字属性，这将在第4章中讨论。</p>
<p>关联模式挖掘最初是在关联规则挖掘的背景下提出的，其中包含一个额外的步骤，基于一种被称为规则置信度的措施。 例如，考虑两组项目A和B.规则A⇒B的置信度被定义为包含A的事务比例，其中也包含B.换言之，置信度是通过将支持的模式 $A∪B$支持模式A.支持和置信的组合用于定义关联规则。</p>
<p><strong>定义 1.4.2（关联规则）</strong> *设$A$和$B$分别为两个元素集。如果满足下面两个条件，则规则$A \Rightarrow B$被认为在支持度$s$和置信度$c$上是有效的：</p>
<ol>
<li>项目集$A$的支持至少为$s$。</li>
<li>规则$A \Rightarrow B$的置信度至少为$c$。*</li>
</ol>
<p>通过在关联规则挖掘算法中引入监督，可以为分类问题提供解决方案。 关联模式挖掘的许多变体也与聚类和异常值分析有关。 这是数据矩阵的水平和垂直分析经常彼此相关的事实的自然结果。 事实上，关联模式挖掘问题的许多变体被用作解决聚类，离群分析和分类问题的子程序。 这些问题将在第4章和第5章讨论。</p>
<p>###1.4.2 数据聚类<br>聚类问题的一个相当广泛和非正式的定义如下：</p>
<p><strong>定义 1.4.3（数据聚类）</strong> <em>给定数据矩阵$D$（数据库$D$），将其行（记录）划分为集合$C_1…C_k$，使得每个群集中的行（记录）彼此“相似”。</em></p>
<p>我们故意在这里提供了一个非正式的定义，因为聚类允许有各种各样的相似性定义，其中有些不是通过相似函数以封闭形式完全定义的。 聚类问题通常可以定义为一个优化问题，其中优化问题的变量代表数据点的集群成员，而目标函数最大化这些变量的组内相似性的具体数学量化。</p>
<p>聚类过程的一个重要部分是为计算过程设计适当的相似度函数。 显然，相似度的计算在很大程度上取决于底层数据类型。 相似性计算的问题将在第3章中详细讨论。相关应用的一些例子如下：</p>
<ul>
<li><p>客户细分：在许多应用程序中，需要在各种产品促销任务的背景下确定彼此类似的客户。 分割阶段在这个过程中起着重要的作用。</p>
</li>
<li><p>数据汇总：由于可以将群集视为相似的记录组，因此可以使用这些相似的群组创建数据摘要。</p>
</li>
<li><p>应用于其他数据挖掘问题：因为聚类被认为是无监督的分类版本，所以它通常被用作解决后者的构建块。 此外，这个问题也用于异常值分析问题的背景下，如下所述。</p>
</li>
</ul>
<p>数据聚类问题将在第6章和第7章中详细讨论。</p>
<p>###1.4.3 离群值检测<br>异常值是一个与其余数据显着不同的数据点。 霍金斯正式定义了异常值的概念如下：</p>
<blockquote>
<p>“异常值是一种观察结果，与其他观察结果有很大差异，引起人们怀疑它是由不同机制产生的。”</p>
</blockquote>
<p>数据挖掘和统计学文献中异常值也被称为异常，不一致，异常或异常。 在大多数应用中，数据由一个或多个生成过程创建，这些生成过程既可以反映系统中的活动，也可以收集有关实体的观察结果。 当生成过程以不寻常的方式运行时，会导致创建异常值。 因此，异常常常包含有关影响数据生成过程的系统和实体的异常特征的有用信息。 对这种不寻常特性的认识提供了有用的应用特定见解。 异常值检测问题根据数据矩阵非正式地定义如下：</p>
<p><strong>定义1.4.4（离群值检测）</strong> <em>给定一个数据矩阵$D$，确定与矩阵中其余行非常不同的数据矩阵的行。</em></p>
<p>异常值检测问题与互补性的聚类问题有关。 这是因为异常值对应于数据中主要组的不同数据点。 另一方面，数据中的主要群体是群集。 实际上，确定异常值的简单方法使用群集作为中间步骤。 相关应用的一些例子如下：</p>
<ul>
<li><p>入侵检测系统：在很多联网的计算机系统中，收集关于操作系统调用，网络流量或系统中其他活动的不同类型的数据。 由于恶意行为，这些数据可能会显示异常行为。 这种活动的检测被称为入侵检测。</p>
</li>
<li><p>信用卡欺诈：未经授权使用信用卡可能会显示不同的模式，例如来自地理位置不明的地点的抢购。 这种模式可能会在信用卡交易数据中显示为异常值。</p>
</li>
<li><p>有趣的传感器事件：传感器通常用于追踪许多实际应用中的各种环境和位置参数。 潜在模式的突然变化可能代表感兴趣的事件。 事件检测是传感器网络领域的主要激励应用之一。</p>
</li>
<li><p>医学诊断：在许多医学应用中，数据来自各种设备，如磁共振成像（MRI），正电子发射断层扫描（PET）扫描或心电图（ECG）时间序列。 这些数据中的不寻常模式通常会反映疾病状况。</p>
</li>
<li><p>执法：异常值检测可以在执法中找到许多应用，尤其是在通过实体的多种行为才能发现异常模式的情况下。 在金融交易，交易活动或保险索赔中识别欺诈行为通常需要确定由犯罪实体的行为产生的数据中的不寻常模式。</p>
</li>
<li><p>地球科学：通过卫星或遥感等多种机制收集大量有关天气模式，气候变化或土地覆盖格局的时空数据。 这些数据的异常提供了关于可能导致这种异常的隐藏的人类或环境趋势的重要见解。</p>
</li>
</ul>
<p>第8章和第9章详细研究了异常值检测问题。</p>
<p>###1.4.4 数据分类<br>许多数据挖掘问题都是针对一个专门的目标，有时由数据中特定功能的价值来表示。 这个特殊的功能被称为类标签。 因此，监督这些问题，其中关于该特殊特征的数据中的其余特征的关系被学习。 用来学习这些关系的数据被称为训练数据。 然后可以使用所学习的模型来确定缺少标签的记录的估计分类标签。</p>
<p>例如，在目标市场营销应用中，每个记录可以由表示客户对特定产品的兴趣（或缺乏）的特定标签标记。 与客户相关的标签可能源自客户以前的购买行为。 另外，也可以提供对应于客户人口统计的一组特征。 目标是通过将人口特征与类别标签相关联来预测其购买行为未知的客户是否对特定产品感兴趣。 因此，建立了一个训练模型，然后用它来预测班级标签。 分类问题非正式地定义如下：</p>
<p><strong>定义 1.4.5（数据分类）</strong> <em>给定一个$n \times d$训练数据矩阵$D$（数据库$D$）和一个类标签值${1…k}$与D中的n行（D中的记录）中的每一行相关联，创建训练模型$M$，其可用于预测$d$维记录$\overline{Y}\not\in D$。</em></p>
<p>类别标签未知的记录被称为测试记录。 研究聚类和分类问题之间的关系是很有趣的。 在聚类问题的情况下，根据相似性将数据分成k个组。 在分类问题的情况下，（测试）记录也被分为k组中的一组，除了这是通过从训练数据库D中学习模型而不是基于相似性来实现的。 换句话说，训练数据的监督重新定义了一组“相似”记录的概念。因此，从学习的角度来看，聚类通常被称为无监督学习（因为缺乏一个专门的训练数据库来“教”关于合适分组概念的模型），而分类问题被称为监督学习。</p>
<p>分类问题与关联模式挖掘有关，后者常常用于解决前者。 这是因为如果整个训练数据库（包括类标签）被视为一个$n \times (d+1) $矩阵，则包含该矩阵中的类标签的频繁模式提供了有关其他特征与类标签相关性的有用提示。 事实上，许多形式的分类器（称为基于规则的分类器）都基于这个更广泛的原则。</p>
<p>分类问题可以通过在后者中引入监督来映射到异常值检测问题的特定版本。 尽管假设缺失检测问题在默认情况下是无人监督的，但是可以部分或完全监督该问题的多种变化。 在受监督的异常值检测中，可以使用一些异常值的例子。 因此，这些数据记录被标记为属于一个罕见的类别，而其余的数据记录属于正常的类别。 因此，监督异常值检测问题映射到二元分类问题，同时警告类别标签高度不平衡。</p>
<p>由于使用了特定于应用程序的类别标签，监督的结合使得分类问题在其直接应用程序特定方面是独一无二的。 与其他主要数据挖掘问题相比，分类问题相对独立。 例如，聚类和频繁模式挖掘问题更常用作大型应用程序框架的中间步骤。 即使是异常值分析问题有时也是以探索的方式使用。 另一方面，分类问题通常直接作为许多应用中的独立工具使用。 使用分类问题的应用示例如下：</p>
<ul>
<li>目标营销：通过使用培训模式，关于顾客的特征与他们的购买行为有关。</li>
<li>入侵检测：计算机系统中的客户活动序列可用于预测入侵的可能性。</li>
<li>监督异常检测：当以前的异常值的例子可用时，罕见的类可能会从正常类中区分开来。</li>
</ul>
<p>数据分类问题将在第10和11章进行详细讨论。</p>
<h3 id="1-4-5-复杂数据类型对问题定义的影响"><a href="#1-4-5-复杂数据类型对问题定义的影响" class="headerlink" title="1.4.5 复杂数据类型对问题定义的影响"></a>1.4.5 复杂数据类型对问题定义的影响</h3><p>特定的数据类型对可能定义的问题类型有着深远的影响。 特别是在依赖于数据类型的数据类型中，依赖关系通常在问题定义，解决方案或两者中起着关键作用。 这是因为上下文属性和依赖关系对于如何评估数据通常很重要。 此外，由于复杂的数据类型更丰富，它们允许制定新的问题定义，甚至可能不存在于多维数据的背景下。 表1.2提供了面向依赖数据类型的数据挖掘问题的不同变化的表格摘要。 下面将简要回顾一下数据类型如何影响不同的问题定义。</p>
<p><center>表1.2 用数据类型定义问题变化的一些例子</center><br><img src="http://p6atp7tts.bkt.clouddn.com/15249065611953.jpg" alt=""></p>
<h4 id="1-4-5-1-复杂数据类型的模式挖掘"><a href="#1-4-5-1-复杂数据类型的模式挖掘" class="headerlink" title="1.4.5.1 复杂数据类型的模式挖掘"></a>1.4.5.1 复杂数据类型的模式挖掘</h4><p>关联模式挖掘问题通常以集合的形式从基础数据中确定模式; 但是，当数据中存在依赖关系时情况并非如此。 这是因为依赖关系和关系经常会在数据项之间进行排序，直接使用频繁模式挖掘方法无法识别不同数据值之间的关系。 例如，当大量的时间序列可用时，它们可以用来确定不同种类的时间频繁模式，其中时间顺序被强加在模式中的项目上。 此外，由于存在表示时间的附加上下文属性，所以时间模式可以以与基于集合的模式相比更加丰富的方式定义，如在关联模式挖掘中那样。 这些模式可能在时间上是连续的，如在时间序列图案中，或者它们可能是周期性的，如在周期性模式中。这些时间模式挖掘方法中的一些将在第14章中讨论。对于离散序列挖掘的情况存在类似的类比，除了个别模式成分是分类的，而不是连续的。 也可以为空间场景定义二维图案，这种公式对图像处理很有用。 最后，结构模式通常在与数据中频繁子图相对应的网络中定义。 因此，节点之间的依赖包含在模式的定义中。</p>
<h4 id="1-4-5-2-复杂数据类型的聚类"><a href="#1-4-5-2-复杂数据类型的聚类" class="headerlink" title="1.4.5.2 复杂数据类型的聚类"></a>1.4.5.2 复杂数据类型的聚类</h4><p>用于聚类的技术也受到基础数据类型的显着影响。 最重要的是，相似性函数显着受数据类型影响。 例如，在时间序列，顺序或图形数据的情况下，一对时间序列之间的相似性不能通过使用直接的度量（如欧几里德度量）来轻松定义。 相反，有必要使用其他种类的指标，例如编辑距离或结构相似性。 在空间数据的背景下，轨迹聚类对于发现移动数据或多变量时间序列的相关模式特别有用。 对于网络数据，聚类问题发现密集连接的节点组，也称为社区检测。</p>
<h4 id="1-4-5-3-复杂数据类型的异常值检测"><a href="#1-4-5-3-复杂数据类型的异常值检测" class="headerlink" title="1.4.5.3 复杂数据类型的异常值检测"></a>1.4.5.3 复杂数据类型的异常值检测</h4><p>依赖关系可以用来定义数据项的期望值。 这些预期值的偏差是异常值。 例如，时间序列值的突然跳跃会导致跳跃发生的特定点的位置异常。 这些方法的想法是使用基于预测的技术来预测该位置的价值。 据报道，与预测有显着差异的位置异常。 这种异常值可以在时间序列，空间和时序数据的背景下定义，其中可以使用自回归，马尔可夫或其他模型检测与相应邻域的显着偏差。 在图数据的上下文中，异常值可能对应于节点，边或整个子图的不寻常特性。 因此，复杂的数据类型在可以定义异常值的方面表现出显着的丰富性。</p>
<h4 id="1-4-5-4-复杂诗句类型的分类"><a href="#1-4-5-4-复杂诗句类型的分类" class="headerlink" title="1.4.5.4 复杂诗句类型的分类"></a>1.4.5.4 复杂诗句类型的分类</h4><p>分类问题还显示了不同复杂数据类型的显着变化量。例如，班级标签可以附加到一系列的特定位置，也可以附加到整个系列。当类别标签附加到系列中的特定位置时，可用于执行监督式事件检测，其中第一次出现特定事件标签（例如，由基础温度和压力提示的机器故障传感器）表示事件的发生。对于网络数据的情况，标签可以连接到非常大的网络中的单个节点，或者连接到多个图形集合中的整个图形。前一种情况对应于社会网络中节点的分类，也被称为集体分类。后一种情况对应于化合物分类问题，其中标签基于其化学性质附着于化合物。</p>
<h2 id="1-5-可伸缩性问题和流式场景"><a href="#1-5-可伸缩性问题和流式场景" class="headerlink" title="1.5 可伸缩性问题和流式场景"></a>1.5 可伸缩性问题和流式场景</h2><p>可扩展性是许多数据挖掘应用中的一个重要问题，因为现代应用中数据的规模越来越大。 广义而言，可扩展性有两个重要场景：</p>
<ol>
<li><p>数据存储在一台或多台机器上，但数量太大，无法高效处理。 例如，在整个数据可以保存在主内存中的情况下，设计高效的算法很容易。 当数据存储在磁盘上时，设计算法以使对磁盘的随机访问最小化非常重要。 对于非常大的数据集，可能需要使用大数据框架，例如MapReduce。 本书将在需要的地方介绍磁盘驻留处理级别的这种可扩展性。</p>
</li>
<li><p>这些数据会随着时间的推移而连续生成，并且完全无法存储。 这种情况是数据流的情况，数据需要使用在线方式进行处理。</p>
</li>
</ol>
<p>后一种情况需要进一步阐述。 由于数据收集技术的进步，随着时间的推移可以收集大量数据，流式场景变得越来越流行。 例如，日常生活中的简单交易（例如使用信用卡或电话）可能会导致自动收集数据。 在这种情况下，数据量太大，直接存储可能不切实际。 相反，所有算法必须在数据上一次执行。 在数据流处理方面出现的主要挑战如下：</p>
<ol>
<li><p>单通约束：算法需要一次处理整个数据集。 换句话说，在处理完数据项目并收集了相关的总结见解后，原始项目将被丢弃并且不再可用于处理。 在给定时间可以处理的数据量取决于可用于保留数据段的存储空间。</p>
</li>
<li><p>概念漂移：在大多数应用中，数据分布随时间而变化。 例如，一天中某一小时的销售模式可能与一天中另一小时的销售模式不同。 这也导致了挖掘算法的输出变化。</p>
</li>
</ol>
<p>由于数据模式随时间而变化的速率以及基础数据中不断演变的模式，因此设计这些场景的算法通常很具挑战性。 对于流挖掘方法在第12章中得到解决。</p>
<h2 id="1-6-典型应用场景介绍"><a href="#1-6-典型应用场景介绍" class="headerlink" title="1.6 典型应用场景介绍"></a>1.6 典型应用场景介绍</h2><p>在本节中，将讨论一些常见的应用场景。 目标是说明问题和应用的广泛多样性，以及它们如何映射到本章讨论的某些构件块。</p>
<h3 id="1-6-1-产品放置位置"><a href="#1-6-1-产品放置位置" class="headerlink" title="1.6.1 产品放置位置"></a>1.6.1 产品放置位置</h3><p>应用场景可以表述如下：<br><strong>应用 1.6.1（产品放置位置）</strong> <em>商家拥有一套$d$产品，以及来自顾客的以前交易，其中包含一起购买的物品篮。 商家希望知道如何将产品放置在货架上，以增加经常一起购买的商品被放置在相邻货架上的可能性。</em></p>
<p>此问题与频繁模式挖掘密切相关，因为分析师可以使用频繁模式挖掘问题来确定在特定支持级别经常一起购买的项目组。这里需要注意的一点是，在提供有用见解的同时，确定频繁模式并不能为商家提供关于如何将产品放置在不同货架上的准确指导。这种情况在数据挖掘中很常见。积木问题往往不能直接解决手头的问题。在这种特殊情况下，商家可以从各种启发式的想法中选择产品如何储存在不同的货架上。例如，商家可能已经拥有现有的展示位置，并且可能会使用频繁模式为展示位置的质量创建一个数字分数。通过对当前展示位置进行增量更改，可以连续优化此展示位置。使用适当的初始化方法，频繁模式挖掘方法可以作为该问题非常有用的子程序。数据挖掘的这些部分通常是特定于应用程序的，并且在不同领域显示出如此大的差异，因此只能通过实践经验来学习。</p>
<h3 id="1-6-2-用户推荐"><a href="#1-6-2-用户推荐" class="headerlink" title="1.6.2 用户推荐"></a>1.6.2 用户推荐</h3><p>这是数据挖掘文献中经常遇到的问题。 这个问题存在许多变化，取决于该应用程序可用的输入数据的类型。 在下文中，我们将研究推荐问题的具体实例并提供一个解决方案。</p>
<p><strong>应用 1.6.2(用户推荐)</strong> <em>商家有一个$n×d$的二元矩阵$D$，表示$n$个客户在$d$个项目上的购买行为。 假定矩阵是稀疏的，因此每个客户可能只购买了几件商品。 最好使用产品关联向顾客提供建议。</em></p>
<p>这个问题是在数据挖掘和推荐文献中广泛研究的协作过滤问题的简单版本。 实际上，这个问题的数以千计的解决方案都是针对这个问题的，我们提供了三个不同的复杂度示例：</p>
<ol>
<li><p>这个问题是在数据挖掘和推荐文献中广泛研究的协作过滤问题的简单版本。 实际上，这个问题的数以千计的解决方案都是针对这个问题的，我们提供了三个不同的复杂度示例：</p>
</li>
<li><p>以前的解决方案不使用不同客户之间的相似性来提出建议。 第二种解决方案是确定与目标客户最相似的行，然后推荐发生在这些相似行中的最常见的项目。</p>
</li>
<li><p>最终的解决方案是使用群集来创建类似客户的细分。 在每个类似的部分中，关联模式挖掘可用于提出建议。</p>
</li>
</ol>
<p>因此，可以有多种方法来解决与不同分析路径相对应的特定问题。 这些不同的路径可能使用不同的构建块，这些构建块在数据挖掘过程的不同部分都是有用的。</p>
<h3 id="1-6-3-医疗诊断"><a href="#1-6-3-医疗诊断" class="headerlink" title="1.6.3 医疗诊断"></a>1.6.3 医疗诊断</h3><p>医疗诊断已成为数据挖掘背景下的常见应用。 医疗诊断中的数据类型往往比较复杂，可能与图像，时间序列或离散序列数据相对应。 因此，依赖性导向的数据类型在医疗诊断应用中往往是相当普遍的。 一个特殊情况是来自心脏病人的心电图读数。</p>
<p><strong>应用 1.6.3（医用心电图诊断）</strong> <em>考虑从不同患者收集的一组ECG时间序列。 从该组中确定异常系列是可取的。</em></p>
<p>这个应用程序可以映射到不同的问题，这取决于可用输入数据的性质。 例如，考虑以前没有可用的异常ECG系列的例子。 在这种情况下，问题可以映射到异常值检测问题。 时间序列与数据中剩余序列的差异可能被认为是异常值。 但是，如果以前的正常和异常系列的例子可用，解决方法的方法会发生显着变化。 在这种情况下，问题会映射到时间序列数据的分类问题。 此外，由于异常系列的数量通常远少于正常系列的数量，因此类别标签可能会失衡。</p>
<h3 id="1-6-4-Web日志异常"><a href="#1-6-4-Web日志异常" class="headerlink" title="1.6.4 Web日志异常"></a>1.6.4 Web日志异常</h3><p>网络日志通常收集在不同网站的主机上。 这些日志可用于检测该网站的异常，可疑或恶意活动。 金融机构定期分析其现场的日志以检测入侵企图。</p>
<p><strong>应用 1.6.4（Web日志异常）</strong> <em>一组Web日志可用。 希望从Web日志中确定异常序列。</em></p>
<p>由于数据通常以原始日志的形式提供，因此需要大量的数据清理。 首先，原始日志需要转换为符号序列。 然后可能需要将这些序列分解成更小的窗口以分析特定粒度水平的序列。 可以通过使用序列聚类算法来确定异常序列，然后确定不在这些聚类中的序列。 如果希望发现与异常相对应的特定位置，则可以使用更复杂的方法（如马尔可夫模型）来确定异常。</p>
<p>和前面的情况一样，这个问题的分析阶段可以建模得很不同，这取决于Web日志异常的例子是否可用。 如果以前没有Web日志异常的例子可用，那么这个问题映射到无监督的时间异常值检测问题。 参考文献[5]中介绍了很多用于解决时间异常值检测问题的无监督情况的方法。 本书第14章和第15章也简要讨论了这个话题。 另一方面，当以前的异常情况可用时，则问题映射到罕见的类别检测问题。 这个问题也在参考文献[5]以及本书的第11章中讨论。</p>
<h2 id="1-7-总结"><a href="#1-7-总结" class="headerlink" title="1.7 总结"></a>1.7 总结</h2><p>数据挖掘是一个复杂的多阶段过程。 这些不同的阶段是数据收集，预处理和分析。 数据预处理阶段具有很高的应用特定性，因为数据的不同格式需要应用不同的算法。 处理阶段可能包括数据集成，清理和特征提取。 在某些情况下，特征选择也可能用于锐化数据表示。 数据转换成方便的格式后，可以使用各种分析算法。</p>
<p>许多数据挖掘构建块经常在各种应用场景中重复使用。 这些分别对应于频繁模式挖掘，聚类，异常值分析和分类问题。 针对特定数据挖掘问题的解决方案的最终设计取决于分析师将应用程序映射到不同构建块的技能，或者针对特定应用程序使用新算法。 本书将介绍获得这些分析技能所需的基础知识。</p>
<h2 id="1-8-书目注释"><a href="#1-8-书目注释" class="headerlink" title="1.8 书目注释"></a>1.8 书目注释</h2><p>数据挖掘问题通常由与统计，数据挖掘和机器学习相对应的多个研究团体进行研究。 这些社区高度重叠，并且经常与许多共同的研究人员共享。 机器学习和统计社区通常从理论和统计的角度来看待数据挖掘。 在这方面写的一些好书可以在[95,256,389]中找到。 但是，由于机器学习社区通常侧重于监督学习方法，因此这些书大多集中在分类场景。 [250,485,536]中可以找到更广泛的数据挖掘书籍，这些书籍是从更广泛的角度编写的。 由于数据挖掘过程通常需要与数据库进行交互，许多相关的数据库教科书[434,194]提供了有关数据表示和集成问题的知识。</p>
<p>在数据挖掘的各个主要领域也编写了许多书籍。 [34]中详细介绍了频繁模式挖掘问题及其变化。关于数据聚类的主题已经写了很多书。众所周知的数据聚类书[284]讨论了来自文献的经典技术。另一本书[219]讨论了最近的数据聚类方法，虽然材料有点基础。文献中最近的一本书[32]提供了对不同数据聚类算法的全面概述。数据分类问题已经在标准的机器学习书中得到了解决[95,256,389]。分类问题也被模式识别团体广泛研究[189]。关于这个话题的最近的调查可以在[33]中找到。 [89,259]详细研究了异常值检测问题。然而，这些书是从统计的角度出发的，并没有从计算机科学界的角度来解决这个问题。从[5]中的计算机科学界的角度来解决这个问题。</p>
<h2 id="1-9-习题"><a href="#1-9-习题" class="headerlink" title="1.9 习题"></a>1.9 习题</h2><ol>
<li><p>一位分析师从不同的参与者那里收集关于他们喜欢和不喜欢的调查。 随后，分析师将数据上传到数据库，纠正错误或缺失的条目，并在此基础上设计推荐算法。 以下哪项行为代表数据收集，数据预处理和数据分析？ （a）进行调查并上传到数据库，（b）纠正缺失的条目，（c）设计推荐算法。</p>
</li>
<li><p>一下每种数据的数据类型是什么？（a）年龄，（b）工资，（c）邮政编码，（d）居住国，（e）身高，（f）体重</p>
</li>
<li><p>一位分析师从医生那里获取用于数据挖掘目的的医疗笔记，然后将其转换成包含针对每位患者处方的药物的表格。 （a）原始数据和（b）转换数据的数据类型是什么？ （c）将数据转换为称为新格式的过程是什么？</p>
</li>
<li><p>分析人员建立了一个传感器网络，以便在一段时间内测量不同位置的温度。 收集的数据的数据类型是什么？</p>
</li>
<li><p>上面练习4中讨论过的同一个分析师从另一个包含压力读数的数据源中找到另一个数据库。 她决定创建一个包含自己的读数和压力读数的单一数据库。 创建这样一个单一的数据库的过程是什么？</p>
</li>
<li><p>分析人员处理Web日志，以便为来自不同用户的Web页面访问的订购信息创建记录。 这些数据的类型是什么？</p>
</li>
<li><p>考虑一个数据对象，它对应于按一定顺序排列的一组核苷酸。 这类数据是什么？</p>
</li>
<li><p>希望根据他们的人口统计资料将客户划分为相似的群体。 哪个数据挖掘问题最适合这项任务？</p>
</li>
<li><p>假设在练习8中，商人已经知道一些客户是否已经购买了小部件。 哪个数据挖掘问题适合于识别剩余客户群体的任务，谁可能会在未来购买小部件？</p>
</li>
<li><p>假设在练习9中，商家还可以获得顾客购买的其他商品（超出小工具）的信息。 哪个数据挖掘问题最适合查找通常与小部件一起购买的项目集？</p>
</li>
<li><p>假设少数客户对他们的人口统计资料有不同的看法，这会导致购买行为和人口统计资料之间的不匹配，正如与其余数据相比所暗示的那样。 哪个数据挖掘问题最适合寻找这些客户？</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.liyaolife.com/dmtrans-pre/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Li Yao">
      <meta itemprop="description" content="程序员的成长之路| 前端设计&GIS开发 | 图书馆里的扫地僧 少林寺里的清洁工">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yao Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/dmtrans-pre/" class="post-title-link" itemprop="url">《Data Mining》翻译前期准备</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-22 18:12:30" itemprop="dateCreated datePublished" datetime="2018-04-22T18:12:30+08:00">2018-04-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-14 10:23:05" itemprop="dateModified" datetime="2019-11-14T10:23:05+08:00">2019-11-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DataMining/" itemprop="url" rel="index">
                    <span itemprop="name">DataMining</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="全书概览"><a href="#全书概览" class="headerlink" title="全书概览"></a>全书概览</h1><p>《Data Mining》一书由Charu C.Aggarwal所著，出版于2015年4月14日，目前没有引进中国，亚马逊原版教材售价约为350元（会员价，非会员1000+）。豆瓣无评分，亚马逊评分4星（5星满分），从CSDN社区一些讨论情况来看，普遍认为本书质量较高。故我们选取本书进行翻译，旨在帮助更多中国学习者阅读优秀教材。</p>
<p>全书共有20章，743页，内容详细，逻辑严谨，其中包含大量图表与公式。</p>
<h1 id="协作方案"><a href="#协作方案" class="headerlink" title="协作方案"></a>协作方案</h1><p>Markdown是当前比较流行的轻量级标记语言，适合快速简便的编辑出高质量的文本。</p>
<p>本团队采用Markdown进行写作。目前有30左右加入团队。<br>初步分工</p>
<ul>
<li>20-23人进行专职翻译</li>
<li>将全书分为3个部分，由3人担任小组长，负责督促本组的进度</li>
<li>3人负责翻译过程中的技术支持</li>
<li>3人负责最终成书的统稿校对</li>
</ul>
<p>按照自愿报名原则，鼓励能者多劳，即一人可以参加全部上述四个流程。</p>
<h1 id="技术难点"><a href="#技术难点" class="headerlink" title="技术难点"></a>技术难点</h1><ol>
<li>Markdown使用，考虑到本团队所有成员均为985院校硕（博）士，初步认为即使没有Markdown基础，也可以快速上手</li>
<li>英语水平，提倡采用Google翻译，毕竟是人类智慧的精华，但是要求机翻之后必须有检查。</li>
<li>公式编辑，Markdown支持LaTeX的公式书写，所以本书公式全部采用LaTeX语法进行书写，部分同学可能不太熟悉，由技术团队提供支持</li>
<li>图、表插入，为了节省时间，本书不再对原书图表进行重绘，图表以及其编号保持与原书一致。但是Markdown中的图表与Word不一样，不是嵌在文件中的，而是一个路径指向一个图片文件，这种做法在生成PDF之后倒看不出来，但是直接分享.md源文件时就会出现问题（比如，写一个Python或者C程序中读取了一个文件，是通过一个路径指向这个文件，那么分享的时候需要把这个文件也带上）。目前在互联网博客中，主流的解决方案是采用图床（相当于一个云盘，把图片存里面）然后在Markdown文件中放该图片对应的url地址。这部分解决起来稍麻烦，在前期工作中可以先跳过，主要翻译文字和公式。</li>
</ol>
<h1 id="进度安排"><a href="#进度安排" class="headerlink" title="进度安排"></a>进度安排</h1><p>全书翻译计划时间为4周。2018.4.23-2018.5.20</p>
<ul>
<li>4.23-5.6，主要进行翻译核心工作，文字和公式部分的翻译。</li>
<li>5.7-5.13，主要进行统稿工作。汇总各人的工作，帮助部分同学解决图片插入问题。形成初稿。</li>
<li>5.14-5.20，主要进行校对工作。检查翻译质量，校对公式正误，最终成书。</li>
</ul>
<h1 id="具体分工"><a href="#具体分工" class="headerlink" title="具体分工"></a>具体分工</h1><table>
<thead>
<tr>
<th style="text-align:center">章节</th>
<th style="text-align:center">负责人</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">李尧</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">程琳</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">朱广阳</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">曹春，张巍烨</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">徐建秋</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">杨天威，刘丹阳</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">张万龙</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">司呈呈</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">王俊</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">刘立新，于雷</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">彭龙，吴旭桥</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">张伟，朱锦锟</td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center">李建鹏</td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center">逯旺旺，李泰立</td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center">贺亮，蒋孝卿</td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td style="text-align:center">张宇</td>
</tr>
<tr>
<td style="text-align:center">17</td>
<td style="text-align:center">朱向典</td>
</tr>
<tr>
<td style="text-align:center">18</td>
<td style="text-align:center">杨山，刘仲康</td>
</tr>
<tr>
<td style="text-align:center">19</td>
<td style="text-align:center">赵纳森，王建秋</td>
</tr>
<tr>
<td style="text-align:center">20</td>
<td style="text-align:center">宋宇</td>
</tr>
</tbody>
</table>
<p>其余人员</p>
<table>
<thead>
<tr>
<th>小组长</th>
<th>技术组</th>
<th>校对组</th>
</tr>
</thead>
<tbody>
<tr>
<td>李尧（1-6章）</td>
<td>李尧</td>
<td>刘蕾</td>
</tr>
<tr>
<td>王俊（7-13章）</td>
<td>程琳</td>
<td>孙旭</td>
</tr>
<tr>
<td>蒋孝卿（14-20章）</td>
<td>陈南宇</td>
<td>李楚茵</td>
</tr>
<tr>
<td></td>
<td>柯达</td>
<td>李润浩</td>
</tr>
<tr>
<td></td>
<td>程煜</td>
<td>杨刚</td>
</tr>
</tbody>
</table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.liyaolife.com/hexo5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Li Yao">
      <meta itemprop="description" content="程序员的成长之路| 前端设计&GIS开发 | 图书馆里的扫地僧 少林寺里的清洁工">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yao Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/hexo5/" class="post-title-link" itemprop="url">hexo博客搭建（五）SEO优化</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-02 20:29:45" itemprop="dateCreated datePublished" datetime="2018-04-02T20:29:45+08:00">2018-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-14 14:07:39" itemprop="dateModified" datetime="2019-11-14T14:07:39+08:00">2019-11-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Hexo/" itemprop="url" rel="index">
                    <span itemprop="name">Hexo</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="与GitHub仓库互联"><a href="#与GitHub仓库互联" class="headerlink" title="与GitHub仓库互联"></a>与GitHub仓库互联</h1><p>直到目前，我们的blog还只是一个本地的小家伙，像一个没有出过门的孩子，只能在localhost:4000里面查看。别人是看不到的。那么如何把它部署到线上？</p>
<p>一般建网站的都需要租服务器，买VPS，亚马逊，阿里云等等，还要花一笔小钱。</p>
<p>好在我们有GitHub。</p>
<p>GitHub提供里代码托管服务，作为全世界最大的程序员社区，自然不缺乏脑洞清奇的人，很多人在上面做各种各样的事情，这是后话。</p>
<p>如果是首次使用GitHub，配置过程是比较复杂的，可先看一下<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰的git教程</a>。</p>
<p>假定我们已经配好了环境，那么就很容易了。</p>
<p>在GitHub上面新建一个repo，注意项目名称为  “用户名.github.io”否则之后是无法访问的，一个账户只能建一个github pages。之后将之前的public文件夹里的内容都同步到这个项目的master分支，之后浏览器访问用户名.github.io就能看到hexo的博客界面了。</p>
<p>比如我的repo 名字是<br><img src="http://upload-images.jianshu.io/upload_images/11400909-2489f8b1cadd7dc0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>那我在浏览器地址栏输入 generalli95.github.io就可以访问我的网页了！</p>
<p>使用git 命令去push需要先hexo generate，还是略显麻烦，hexo提供了一个插件hexo-deployer-git可以打包git命令。</p>
<p>插件安装,命令行先cd到blog，然后输入下面命令。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-deployer-git <span class="comment">--save</span></span><br></pre></td></tr></table></figure></p>
<p>然后在博客的配置文件_config.yml，添加<br><img src="http://upload-images.jianshu.io/upload_images/11400909-4bab54cc5b099520.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<font color="red">注意：把repo:后面换成自己的repo名字！</font>

<p>然后hexo generate之后，再hexo deploy就可以自动部署了，支持短命令，hexo g -d,相当于前两个命令的合体！</p>
<h1 id="换上自己的域名"><a href="#换上自己的域名" class="headerlink" title="换上自己的域名"></a>换上自己的域名</h1><p>得益于当年的中二岁月……申请github的时候非要起个什么英文名字，然后……自己都打不对自己的网页全名，因为实在是太长了？</p>
<p>所以，要不自己注册个域名，这样显得很酷炫，而且说不定哪天域名还能卖个好价钱，想想还真得好激动呢（白日梦）。</p>
<h2 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h2><p>购买域名的具体操作。推荐先看一下这篇文章： <a href="https://zhuanlan.zhihu.com/p/27349039" target="_blank" rel="noopener">推荐几家域名注册服务商</a>。<br>我是在Godaddy上注册的域名，网站有中文版支持支付宝支付还是很友好的。域名前两年有活动，前两年109块，后面每年100多一点，价格不贵。并且这可能也是我们这个博客搭建过程中唯一需要花钱的地方。</p>
<h2 id="设置DNS解析"><a href="#设置DNS解析" class="headerlink" title="设置DNS解析"></a>设置DNS解析</h2><p>实际上这也不是一个必须的服务，但是由于Godaddy是一个国外厂商，直接使用它的DNS速度有影响，所以为了保证域名在国内的解析速度。推荐使用DNSPod的DNS解析服务。</p>
<p><font color="red">DNSPod</font>已经被腾讯云收购，所以用微信可以直接登录。<br>登录DNSPod之后按照提示，再到Godaddy里面把DNS修改一下。<br><img src="http://upload-images.jianshu.io/upload_images/11400909-1c39056181935b67.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>然后为了使GitHub接收这个域名，还需要博客的根目录下添加一个名为CNAME的文件（不要加.txt）。<br>这个文件放到主题文件夹的source里面，文件里面放你的域名（去掉www），比如我的网站，文件里面就放一句话：liyaolife.com<br>然后在如上图所示界面里面，添加两条记录，一个主机记录写@，另一个写www，这样无论用户输入<a href="http://www.liyaolife.com">www.liyaolife.com</a> 还是只输入 liyaolife.com 都可以直接定位到我的网站了，记录值放自己的GitHub Pages地址。</p>
<p>OK，现在可以把这个URL转到微信群里面跟爸爸妈妈还有小伙伴们炫耀一番了。</p>
<hr>
<p>本文首发于个人网页<a href="http://liyaolife.com" target="_blank" rel="noopener">Yao Blog</a>，知乎专栏<a href="https://zhuanlan.zhihu.com/c_175317330" target="_blank" rel="noopener">谈技术 不能潦草</a>，CSDN博客：<a href="https://blog.csdn.net/GeneralLi95" target="_blank" rel="noopener">手握灵珠常奋笔</a>，简书：<a href="https://www.jianshu.com/u/2ad44a001d34" target="_blank" rel="noopener">且自小尧没谁管</a>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.liyaolife.com/Hexo4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Li Yao">
      <meta itemprop="description" content="程序员的成长之路| 前端设计&GIS开发 | 图书馆里的扫地僧 少林寺里的清洁工">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yao Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/Hexo4/" class="post-title-link" itemprop="url">Hexo博客搭建（四） 主题设置</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-04-02 20:29:06" itemprop="dateCreated datePublished" datetime="2018-04-02T20:29:06+08:00">2018-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-14 13:58:14" itemprop="dateModified" datetime="2019-11-14T13:58:14+08:00">2019-11-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Hexo/" itemprop="url" rel="index">
                    <span itemprop="name">Hexo</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Hexo支持大家自定义主题样式，所以不甘寂寞的高手们为此做了大量的工作，创作出了大量优秀的主题供我们选择。本文主要写一下如何选择，设置主题。不涉及如何自定义一个主题。</p>
<h2 id="从哪里找主题"><a href="#从哪里找主题" class="headerlink" title="从哪里找主题"></a>从哪里找主题</h2><ul>
<li><a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo官网主题页面</a></li>
<li><a href="https://github.com/search?utf8=✓&amp;q=hexo+theme&amp;type=" target="_blank" rel="noopener">GitHub搜索 hexo theme</a></li>
</ul>
<p><a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">yilia主题</a> 的作者曾说过，她的主题设计原则是</p>
<blockquote>
<p>崇尚简约<br>追求移动端体验<br>希望把加载速度做到极致（努力中）<br>让大家把注意力放到内容上。这是本主题设计初衷<br>主题不支持IE6，7，8。以后也不会</p>
</blockquote>
<p>深得我心，作为文艺又浪漫的技术人员，我们的博客不是QQ空间，不需要那么多花里胡哨的装扮，真正重要的是内容。</p>
<p>所以在建议大家不要花太多的时间用在选主题上。<br>选主题时，注意下面一些问题:</p>
<ul>
<li>主题尽量选通用的，想要个性的话，下下来自己改，尽量避免太小众的主题，除非你有很强的技术能力。因为一些用的比较多的主题已经成为一个开源项目，有很多人维护，并且不断开发新功能。</li>
<li>接口是否全面，在后续的设置中，有SEO优化，社交账号快捷入口，流量统计，评论功能等等一系列可以做的事情，一些好的主题会集成这些功能，接口很全面，直接在博客设置文件里面配置一下就好了。</li>
<li>语言支持，至少支持中英文吧。大部分主题现在还支持emoji，真的十分优秀（相比之下，CSDN就不能显示emoji，不忍直视）</li>
</ul>
<h2 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h2><p>我们以用的最多的<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">NEXT主题</a>为例。</p>
<p>写了半天，发现<a href="https://github.com/iissnan/hexo-theme-next/blob/master/README.cn.md" target="_blank" rel="noopener">NEXT主题的官方中文文档</a>，珠玉在前，不再多言。其他主题的设置大同小异。</p>
<p>向这些优秀主题的贡献者们敬礼👍👍。</p>
<hr>
<p>本文首发于个人网页<a href="http://liyaolife.com" target="_blank" rel="noopener">Yao Blog</a>，知乎专栏<a href="https://zhuanlan.zhihu.com/c_175317330" target="_blank" rel="noopener">谈技术 不能潦草</a>，CSDN博客：<a href="https://blog.csdn.net/GeneralLi95" target="_blank" rel="noopener">手握灵珠常奋笔</a>，简书：<a href="https://www.jianshu.com/u/2ad44a001d34" target="_blank" rel="noopener">且自小尧没谁管</a>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.liyaolife.com/Hexo3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Li Yao">
      <meta itemprop="description" content="程序员的成长之路| 前端设计&GIS开发 | 图书馆里的扫地僧 少林寺里的清洁工">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yao Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/Hexo3/" class="post-title-link" itemprop="url">Hexo博客搭建（三）上线与个性化域名设置</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-28 21:02:29" itemprop="dateCreated datePublished" datetime="2018-03-28T21:02:29+08:00">2018-03-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-14 13:39:26" itemprop="dateModified" datetime="2019-11-14T13:39:26+08:00">2019-11-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Hexo/" itemprop="url" rel="index">
                    <span itemprop="name">Hexo</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="与GitHub仓库互联"><a href="#与GitHub仓库互联" class="headerlink" title="与GitHub仓库互联"></a>与GitHub仓库互联</h1><p>直到目前，我们的blog还只是一个本地的小家伙，像一个没有出过门的孩子，只能在localhost:4000里面查看。别人是看不到的。那么如何把它部署到线上？</p>
<p>一般建网站的都需要租服务器，买VPS，亚马逊，阿里云等等，还要花一笔小钱。</p>
<p>好在我们有GitHub。</p>
<p>GitHub提供里代码托管服务，作为全世界最大的程序员社区，自然不缺乏脑洞清奇的人，很多人在上面做各种各样的事情，这是后话。</p>
<p>如果是首次使用GitHub，配置过程是比较复杂的，可先看一下<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰的git教程</a>。</p>
<p>假定我们已经配好了环境，那么就很容易了。</p>
<p>在GitHub上面新建一个repo，注意项目名称为  “用户名.github.io”否则之后是无法访问的，一个账户只能建一个github pages。之后将之前的public文件夹里的内容都同步到这个项目的master分支，之后浏览器访问用户名.github.io就能看到hexo的博客界面了。</p>
<p>比如我的repo 名字是<br><img src="http://upload-images.jianshu.io/upload_images/11400909-2489f8b1cadd7dc0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>那我在浏览器地址栏输入 generalli95.github.io就可以访问我的网页了！</p>
<p>使用git 命令去push需要先hexo generate，还是略显麻烦，hexo提供了一个插件hexo-deployer-git可以打包git命令。</p>
<p>插件安装,命令行先cd到blog，然后输入下面命令。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-deployer-git <span class="comment">--save</span></span><br></pre></td></tr></table></figure></p>
<p>然后在博客的配置文件_config.yml，添加<br><img src="http://upload-images.jianshu.io/upload_images/11400909-4bab54cc5b099520.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<font color="red">注意：把repo:后面换成自己的repo名字！</font>

<p>然后hexo generate之后，再hexo deploy就可以自动部署了，支持短命令，hexo g -d,相当于前两个命令的合体！</p>
<h1 id="换上自己的域名"><a href="#换上自己的域名" class="headerlink" title="换上自己的域名"></a>换上自己的域名</h1><p>得益于当年的中二岁月……申请github的时候非要起个什么英文名字，然后……自己都打不对自己的网页全名，因为实在是太长了？</p>
<p>所以，要不自己注册个域名，这样显得很酷炫，而且说不定哪天域名还能卖个好价钱，想想还真得好激动呢（白日梦）。</p>
<h2 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h2><p>购买域名的具体操作。推荐先看一下这篇文章： <a href="https://zhuanlan.zhihu.com/p/27349039" target="_blank" rel="noopener">推荐几家域名注册服务商</a>。<br>我是在Godaddy上注册的域名，网站有中文版支持支付宝支付还是很友好的。域名前两年有活动，前两年109块，后面每年100多一点，价格不贵。并且这可能也是我们这个博客搭建过程中唯一需要花钱的地方。</p>
<h2 id="设置DNS解析"><a href="#设置DNS解析" class="headerlink" title="设置DNS解析"></a>设置DNS解析</h2><p>实际上这也不是一个必须的服务，但是由于Godaddy是一个国外厂商，直接使用它的DNS速度有影响，所以为了保证域名在国内的解析速度。推荐使用DNSPod的DNS解析服务。</p>
<p><font color="red">DNSPod</font>已经被腾讯云收购，所以用微信可以直接登录。<br>登录DNSPod之后按照提示，再到Godaddy里面把DNS修改一下。<br><img src="http://upload-images.jianshu.io/upload_images/11400909-1c39056181935b67.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>然后为了使GitHub接收这个域名，还需要博客的根目录下添加一个名为CNAME的文件（不要加.txt）。<br>这个文件放到主题文件夹的source里面，文件里面放你的域名（去掉www），比如我的网站，文件里面就放一句话：liyaolife.com<br>然后在如上图所示界面里面，添加两条记录，一个主机记录写@，另一个写www，这样无论用户输入<a href="http://www.liyaolife.com">www.liyaolife.com</a> 还是只输入 liyaolife.com 都可以直接定位到我的网站了，记录值放自己的GitHub Pages地址。</p>
<p>OK，现在可以把这个URL转到微信群里面跟爸爸妈妈还有小伙伴们炫耀一番了。</p>
<hr>
<p>本文首发于个人网页<a href="http://liyaolife.com" target="_blank" rel="noopener">Yao Blog</a>，知乎专栏<a href="https://zhuanlan.zhihu.com/c_175317330" target="_blank" rel="noopener">谈技术 不能潦草</a>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.liyaolife.com/Hexo2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Li Yao">
      <meta itemprop="description" content="程序员的成长之路| 前端设计&GIS开发 | 图书馆里的扫地僧 少林寺里的清洁工">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yao Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/Hexo2/" class="post-title-link" itemprop="url">Hexo博客搭建（二）从最简单的开始</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-27 11:16:36" itemprop="dateCreated datePublished" datetime="2018-03-27T11:16:36+08:00">2018-03-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-14 13:37:15" itemprop="dateModified" datetime="2019-11-14T13:37:15+08:00">2019-11-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="安装git-node-hexo"><a href="#安装git-node-hexo" class="headerlink" title="安装git, node, hexo"></a>安装git, node, hexo</h2><p>macOS和Linux中都自带git，使用macOS的强烈建议安装brew，之后使用brew命令安装各种东西都很方便。</p>
<p>假定现在brew和git已经装好了。下面安装node，打开终端</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install node</span></span><br></pre></td></tr></table></figure>
<p>OK，node装好了，之后使用node自带的包管理器(node package management?)安装hexo。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-cli -g</span></span><br></pre></td></tr></table></figure>
<p>如果需要权限的话，在前面加上sudo即可。</p>
<p>OK现在开始新建一个blog。<br>先新建一个文件夹，姑且就命名为blog吧，当然你也可以命名其他名字，终端cd到这个文件夹下面。<br>下面的命令都在blog文件夹里执行。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo init</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo server</span></span><br></pre></td></tr></table></figure>
<p>解释一下这几个命令，hexo init 和git init一样，（init initialization缩写，初始化）使这个blog文件夹成为一个“黑箱”,只有在这里面”hexo“的相关指令才有效，npm install安装相关文件，hexo server，启动本地服务器（默认端口4000），现在打开浏览器，在地址栏输入，localhost:4000。OK一个博客雏形就好了。hexo server  命令可以简写为hexo s。</p>
<p>最开始的界面大概就长这个样子：<br><img src="http://upload-images.jianshu.io/upload_images/11400909-abee9df147ccfa44.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>好像还蛮容易的。<br>参考：<a href="https://shino.space/2016/使用Hexo在GitHub上搭建网站/" target="_blank" rel="noopener">shino的博客</a> ，<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo官网</a></p>
<h2 id="博文写作"><a href="#博文写作" class="headerlink" title="博文写作"></a>博文写作</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo new <span class="built_in">test</span></span></span><br></pre></td></tr></table></figure>
<p>通过这个命令在，blog文件夹下面就有了一个test.md文件。.md表明这是一个Markdown格式的文档，注意如果文档名包含空格的话注意加双引号。</p>
<p>如果要编辑这个文档，使用任何文本编辑器一颗，有一些专用的Markdown编辑器，比如Mou，Macdown，以及我目前用的MWeb（强烈推荐），一些IDE也可以加装Markdown插件，比如Pycharm，Webstorm。当然目前很多高手喜欢用Github出品的号称21世纪的文本编辑器Atom。</p>
<p>总之不管使用什么编辑器，Markdown的语法都是一样的。<br>使用Markdown编辑好，保存。重新hexo s 即可刷新本地的网页。</p>
<h2 id="使用MWeb与七牛云图床优化写作体验"><a href="#使用MWeb与七牛云图床优化写作体验" class="headerlink" title="使用MWeb与七牛云图床优化写作体验"></a>使用MWeb与七牛云图床优化写作体验</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该部分不是必须的，可以跳过。</span><br></pre></td></tr></table></figure>
<p>MWeb作为Mac APP store里面非常优秀的Markdown编辑器。使用MWeb，具体方法，打开MWeb之后Command+E，进入外部模式，跟IDE打开project一样打开blog/soure即可，本地编辑，保存，命令行一键发布，简直不能再爽了。</p>
<p><font color="red">图床是什么鬼，为什么要使用图床？</font><br>当我们在本地做一个Word或者PPT文档的时候，图片的插入非常方便，只要拖进去就行了。</p>
<p>但是也存在一个问题，插入图片越多，文档就越大，打开时间也就越长，一台老机子开一个Word有时候需要30s以上，网页虽然道理不太一样，但是大体也是图片越多，打开越慢。</p>
<p>HTML语言里面，图片都是作为标签引用。有过公众号运营的同学可能有体会，插入图片需要先上传到公众号相册，然后再在相册里面选一下。非常麻烦。那能否直接插入图片？</p>
<p>答案必须是Yes。</p>
<p>这时候图床就派上用场了，拖进去，上传，复制Markdown，这时候你的文档里面是一个<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!<span class="selector-attr">[]</span>(<span class="attribute">http</span>:<span class="comment">//p6atp7tts.bkt.clouddn.com/15222405680070.jpg)</span></span><br></pre></td></tr></table></figure></p>
<p>这样的东西，相当于图片变成了一个源。</p>
<p>Hexo博客其实本身不存在这个问题，因为拖进去的图片会被保存下来，一起上传到GitHub repo里面，相当于自动完成了这个过程。但是这样博客的迁移性就不太好，如果要随便迁移，比如要迁移到微信公众号或CSDN，这个方法就比较有用了。关于MWeb和七牛的配置具体可见下面两个资源。<br><a href="https://blog.csdn.net/crazy1235/article/details/78570367" target="_blank" rel="noopener">MWeb</a> ，<a href="https://www.cnblogs.com/colder219/p/6266296.html" target="_blank" rel="noopener">七牛云图床</a></p>
<p>还有一篇文章，介绍的比较详细，可以看出MWeb+七牛到底有什么好处。<br><a href="https://www.jianshu.com/p/c859ead1b493" target="_blank" rel="noopener">一个码子工作者的正确书写发文姿势</a></p>
<hr>
<p>本文首发于个人网页<a href="http://liyaolife.com" target="_blank" rel="noopener">Yao Blog</a>，知乎专栏<a href="https://zhuanlan.zhihu.com/c_175317330" target="_blank" rel="noopener">谈技术 不能潦草</a>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.liyaolife.com/Hexo1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Li Yao">
      <meta itemprop="description" content="程序员的成长之路| 前端设计&GIS开发 | 图书馆里的扫地僧 少林寺里的清洁工">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yao Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/Hexo1/" class="post-title-link" itemprop="url">Hexo博客搭建（一）前期准备</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-03-24 10:53:24" itemprop="dateCreated datePublished" datetime="2018-03-24T10:53:24+08:00">2018-03-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-14 13:49:30" itemprop="dateModified" datetime="2019-11-14T13:49:30+08:00">2019-11-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一年半前，在网上闲逛时，无意点开了一个个人博客，酷炫。</p>
<p>见贤思齐，看到别人搞的一个博客，感觉自己查查教程应该也可以搞出来。真不知道哪来的自信啊，那时候连GitHub都没用过🙈，搞不清楚GitHub和git是什么关系，很久以前，我一直以为GitHub是git的升级版……</p>
<p>找到一个教程，迷迷糊糊注册一个GitHub账号，fork了别人的一个博客，改成自己的名字。</p>
<p>然后……就没有然后了。</p>
<p>第一次尝试，不了了之。</p>
<hr>
<p>后来玩过一段时间微信公众号，毕业设计的时候开始大量使用CSDN，注册了CSDN blog 也发了四五十篇水文，还有四五个粉丝，熟悉了Markdown的用法，有一种想见恨晚的感觉。</p>
<p>当然，相见恨晚指的是Markdown，不是CSDN，CSDN的界面非常落后，还经常改版，博客上传图片非常麻烦，社区活跃度也基本上不复存在。编程初学阶段还比较友好，用了半年感觉就不够用了（这年头，程序员，GitHub，Stack Overflow，知乎，简书，什么都得用一点）。</p>
<p>毕业设计，搞的是一个3维GIS的显示，用了Cesium库（JavaScript），又花了不少时间粗浅了解了一下前端的东西。但我必须承认，我的毕设是个垃圾。</p>
<hr>
<p>最近两周，进实验室开始做事情，用Python flask框架做了一个项目，后台代码基本上都是自己写的，前端代码由一个工程师帮了很大的忙，最后由导师亲自部署到阿里云去。</p>
<p>以为要做几个月的项目，没想到两三个星期也做完了。信心大增。<br>感觉现在的水平应该可以完成这个小项目了吧。</p>
<p>开干。</p>
<hr>
<p>总结一下，做这么一个小网站，大概需要预备下面的知识（技能）。</p>
<ul>
<li><p>Markdown<br>  Markdown是一种轻量级的标记语言咯，非常简单易懂，五分钟上手，写过三四篇基本可以不再查表。Hexo博客天生支持，可以说为Markdown而生，所以它虽然简单但是，最为重要。</p>
</li>
<li><p>一定的前端能力<br>毕竟是在做一个网页，所以需要一定的前端能力，HTML，JavaScript了解一些足以，除了一些自己定制Theme的高手，CSS基本上用不到。Node.js要安装，它提供了快速的网页渲染。但是不必精通。我在之前复现别人一个GitHub repo的时候，IDE说缺Node.js，然后就装了。Hexo整个应该是基于Node.js写的，所有的插件都可以通过npm非常方便的安装。所以前端能力Need。</p>
</li>
<li><p>熟练的Git技能<br>Git和GitHub技能。因为我们没有租服务器，代码网站的代码实际上是托管在GitHub上面（相当于GitHub给我们免费提供了服务器）。所以Git技能也是必须的。</p>
</li>
<li><p>习惯命令行操作<br>npm包的安装，hexo和Git的很多操作，通过命令行要方便太多太多。我用的MacOS的命令行，Linux与之相似，Windows应该也差不多。</p>
</li>
<li>其他知识<br>诸如计算机网络，等一些大学课堂上可能会教的东西，具备这些知识的话很多操作比较容易理解，不具备也不会有任何影响，这就是一个小工程问题。</li>
</ul>
<hr>
<p>万事俱备，<br>开干！</p>
<hr>
<p>本文首发于个人网页<a href="http://liyaolife.com" target="_blank" rel="noopener">Yao Blog</a>，知乎专栏<a href="https://zhuanlan.zhihu.com/c_175317330" target="_blank" rel="noopener">谈技术 不能潦草</a>，CSDN博客：<a href="https://blog.csdn.net/GeneralLi95" target="_blank" rel="noopener">手握灵珠常奋笔</a>，简书：<a href="https://www.jianshu.com/u/2ad44a001d34" target="_blank" rel="noopener">且自小尧没谁管</a>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="Li Yao"
    src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Li Yao</p>
  <div class="site-description" itemprop="description">程序员的成长之路| 前端设计&GIS开发 | 图书馆里的扫地僧 少林寺里的清洁工</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/GeneralLi95" title="GitHub &rarr; https://github.com/GeneralLi95" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:nudtliyao@foxmail.com" title="E-Mail &rarr; mailto:nudtliyao@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/6379926438" title="Weibo &rarr; https://weibo.com/6379926438" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/li-yao-89-61/activities" title="Zhihu &rarr; https://www.zhihu.com/people/li-yao-89-61/activities" rel="noopener" target="_blank"><i class="fa fa-fw fa-zhihu"></i>Zhihu</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Li Yao</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.6.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.5.0
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  
















  

  

  

</body>
</html>
